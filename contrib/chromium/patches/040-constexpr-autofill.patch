A workaround around a weird issue; apparently we cannot instantiate constexpr
std::strings? It tries to invoke the allocator for copy ctor, which fails.

The patched version requires an exit-time destructor but it should hopefully
not be a problem (especially considering this string will fit in SSO).

note: pointer to subobject of heap-allocated object is not a constant expression
/usr/bin/../include/c++/v1/__memory/allocator.h:112:38: note: heap allocation performed here
  112 |             return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      |              

--- a/components/autofill/core/browser/data_model/autofill_i18n_api.h
+++ b/components/autofill/core/browser/data_model/autofill_i18n_api.h
@@ -15,9 +15,8 @@
 // Country code that represents autofill's legacy address hierarchy model as
 // stored `kAutofillModelRules`. As a workaround for GCC we declare the
 // std::string constexpr first.
-constexpr inline std::string kLegacyHierarchyCountryCodeString{"XX"};
-constexpr AddressCountryCode kLegacyHierarchyCountryCode =
-    AddressCountryCode(kLegacyHierarchyCountryCodeString);
+inline AddressCountryCode kLegacyHierarchyCountryCode =
+    AddressCountryCode("XX");
 
 // Creates an instance of the address hierarchy model corresponding to the
 // provided country. All the nodes have empty values, except for the country
--- a/components/autofill/core/browser/data_model/autofill_i18n_api_unittest.cc
+++ b/components/autofill/core/browser/data_model/autofill_i18n_api_unittest.cc
@@ -100,7 +100,7 @@ TEST_F(AutofillI18nApiTest, GetAddressComponentModel_CountryNodeHasValue) {
     std::unique_ptr<AddressComponent> model = CreateAddressComponentModel(
         AddressCountryCode(std::string(country_code)));
     std::u16string expected_country =
-        country_code != kLegacyHierarchyCountryCodeString
+        country_code != "XX"
             ? base::UTF8ToUTF16(country_code)
             : u"";
     EXPECT_EQ(model->GetValueForType(ADDRESS_HOME_COUNTRY), expected_country);
