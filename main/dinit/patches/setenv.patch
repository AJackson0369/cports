From e029157e8467f10c68ac065d30eabf25bfb185cd Mon Sep 17 00:00:00 2001
From: Daniel Kolesa <daniel@octaforge.org>
Date: Wed, 16 Feb 2022 05:47:42 +0100
Subject: [PATCH] implement dinitctl setenv

---
 src/control.cc              | 62 +++++++++++++++++++++++++++++++++++
 src/dinitctl.cc             | 65 +++++++++++++++++++++++++++++++++++--
 src/includes/control-cmds.h |  3 ++
 src/includes/control.h      |  3 ++
 4 files changed, 131 insertions(+), 2 deletions(-)

diff --git a/src/control.cc b/src/control.cc
index 951ea4d..7b41013 100644
--- a/src/control.cc
+++ b/src/control.cc
@@ -101,6 +101,9 @@ bool control_conn_t::process_packet()
     if (pktType == DINIT_CP_QUERYSERVICENAME) {
         return process_query_name();
     }
+    if (pktType == DINIT_CP_SETENV) {
+        return process_setenv();
+    }
 
     // Unrecognized: give error response
     char outbuf[] = { DINIT_RP_BADREQ };
@@ -789,6 +792,65 @@ bool control_conn_t::process_query_name()
     return queue_packet(std::move(reply));
 }
 
+bool control_conn_t::process_setenv()
+{
+    using std::string;
+
+    string envVar;
+    typename string::size_type eq;
+
+    constexpr int pkt_size = 4;
+    char badreqRep[] = { DINIT_RP_BADREQ };
+    char okRep[] = { DINIT_RP_ACK };
+
+    if (rbuf.get_length() < pkt_size) {
+        chklen = pkt_size;
+        return true;
+    }
+
+    uint16_t envSize;
+    rbuf.extract((char *)&envSize, 1, 2);
+    if (envSize <= 0 || envSize > (1024 - 3)) {
+        goto badreq;
+    }
+    chklen = envSize + 3; // packet type + (2 byte) length + envvar
+
+    if (rbuf.get_length() < chklen) {
+        // packet not complete yet; read more
+        return true;
+    }
+
+    envVar = rbuf.extract_string(3, envSize);
+
+    eq = envVar.find('=');
+    if (!eq || eq == envVar.npos) {
+        // not found or at the beginning of the string
+        goto badreq;
+    }
+
+    envVar[eq] = '\0';
+
+    if (setenv(envVar.c_str(), &envVar[eq + 1], 1) != 0) {
+        // failed to set the var
+        goto badreq;
+    }
+
+    // success response
+    if (! queue_packet(okRep, 1)) return false;
+
+    // Clear the packet from the buffer
+    rbuf.consume(chklen);
+    chklen = 0;
+    return true;
+
+badreq:
+    // Queue error response / mark connection bad
+    if (! queue_packet(badreqRep, 1)) return false;
+    bad_conn_close = true;
+    iob.set_watches(OUT_EVENTS);
+    return true;
+}
+
 bool control_conn_t::query_load_mech()
 {
     rbuf.consume(1);
diff --git a/src/dinitctl.cc b/src/dinitctl.cc
index cbda8b9..86fa3f3 100644
--- a/src/dinitctl.cc
+++ b/src/dinitctl.cc
@@ -49,6 +49,7 @@ static int add_remove_dependency(int socknum, cpbuffer_t &rbuffer, bool add, con
         const char *service_to, dependency_type dep_type, bool verbose);
 static int enable_disable_service(int socknum, cpbuffer_t &rbuffer, const char *from, const char *to,
         bool enable, bool verbose);
+static int do_setenv(int socknum, cpbuffer_t &rbuffer, char **env_names, bool verbose);
 
 static const char * describeState(bool stopped)
 {
@@ -75,7 +76,8 @@ enum class command_t {
     ADD_DEPENDENCY,
     RM_DEPENDENCY,
     ENABLE_SERVICE,
-    DISABLE_SERVICE
+    DISABLE_SERVICE,
+    SETENV,
 };
 
 class dinit_protocol_error
@@ -91,6 +93,7 @@ int main(int argc, char **argv)
     bool show_help = argc < 2;
     const char *service_name = nullptr;
     const char *to_service_name = nullptr;
+    char **env_names = nullptr;
     dependency_type dep_type;
     bool dep_type_set = false;
     
@@ -203,6 +206,12 @@ int main(int argc, char **argv)
             else if (strcmp(argv[i], "disable") == 0) {
                 command = command_t::DISABLE_SERVICE;
             }
+            else if (strcmp(argv[i], "setenv") == 0) {
+                command = command_t::SETENV;
+                if ((i + 1) < argc) {
+                    env_names = &argv[i + 1];
+                }
+            }
             else {
                 cerr << "dinitctl: unrecognized command: " << argv[i] << " (use --help for help)\n";
                 return 1;
@@ -246,7 +255,7 @@ int main(int argc, char **argv)
                 to_service_name = argv[i];
             }
             else {
-                if (service_name != nullptr) {
+                if (service_name != nullptr && (command != command_t::SETENV)) {
                     show_help = true;
                     break;
                 }
@@ -274,6 +283,10 @@ int main(int argc, char **argv)
         show_help = true;
     }
 
+    if ((command == command_t::SETENV) && ! env_names) {
+        show_help = true;
+    }
+
     if (show_help) {
         cout << "dinitctl:   control Dinit services\n"
           "\n"
@@ -292,6 +305,7 @@ int main(int argc, char **argv)
           "    dinitctl [options] rm-dep <type> <from-service> <to-service>\n"
           "    dinitctl [options] enable [--from <from-service>] <to-service>\n"
           "    dinitctl [options] disable [--from <from-service>] <to-service>\n"
+          "    dinitctl [options] setenv [name[=value] ...]\n"
           "\n"
           "Note: An activated service continues running when its dependents stop.\n"
           "\n"
@@ -395,6 +409,9 @@ int main(int argc, char **argv)
             return enable_disable_service(socknum, rbuffer, service_name, to_service_name,
                     command == command_t::ENABLE_SERVICE, verbose);
         }
+        else if (command == command_t::SETENV) {
+            return do_setenv(socknum, rbuffer, env_names, verbose);
+        }
         else {
             return start_stop_service(socknum, rbuffer, service_name, command, do_pin, do_force,
                     wait_for_service, ignore_unstarted, verbose);
@@ -1287,3 +1304,47 @@ static int enable_disable_service(int socknum, cpbuffer_t &rbuffer, const char *
 
     return 0;
 }
+
+static int do_setenv(int socknum, cpbuffer_t &rbuffer, char **env_names, bool verbose)
+{
+    using namespace std;
+
+    string buf;
+
+    while (*env_names) {
+        const char *envp = *env_names++;
+        buf.clear();
+        buf.reserve(6);
+        // protocol message and size space
+        buf.push_back(DINIT_CP_SETENV);
+        buf.append(2, 0);
+        // either full var or name
+        auto elen = strlen(envp);
+        buf.append(envp, elen);
+        // = not found, get value from environment
+        if (!memchr(envp, '=', elen)) {
+            buf.push_back('=');
+            auto *envv = getenv(envp);
+            if (envv) {
+                buf.append(envv);
+            }
+        }
+        uint16_t bufs = buf.size() - 3;
+        // set size in protocol message
+        memcpy(&buf[1], &bufs, 2);
+        // send
+        write_all_x(socknum, buf.data(), bufs + 3);
+        wait_for_reply(rbuffer, socknum);
+        if (rbuffer[0] == DINIT_RP_BADREQ) {
+            if (verbose) {
+                cerr << "dinitctl: failed to export environment." << endl;
+            }
+            return 1;
+        } else if (rbuffer[0] != DINIT_RP_ACK) {
+            throw dinit_protocol_error();
+        }
+        rbuffer.consume(1);
+    }
+
+    return 0;
+}
diff --git a/src/includes/control-cmds.h b/src/includes/control-cmds.h
index 02eada3..cf3e6f4 100644
--- a/src/includes/control-cmds.h
+++ b/src/includes/control-cmds.h
@@ -45,6 +45,9 @@ constexpr static int DINIT_CP_QUERYSERVICENAME = 15;
 // Reload a service:
 constexpr static int DINIT_CP_RELOADSERVICE = 16;
 
+// Export a set of environment variables into activation environment:
+constexpr static int DINIT_CP_SETENV = 17;
+
 // Replies:
 
 // Reply: ACK/NAK to request
diff --git a/src/includes/control.h b/src/includes/control.h
index f4608c7..8c6ccc3 100644
--- a/src/includes/control.h
+++ b/src/includes/control.h
@@ -152,6 +152,9 @@ class control_conn_t : private service_listener
     // Process a QUERYSERVICENAME packet.
     bool process_query_name();
 
+    // Process a SETENV packet.
+    bool process_setenv();
+
     // List all loaded services and their state.
     bool list_services();
 
