#!/bin/sh

CMDLINE="$*"

# there might be root= in the original cmdline
for part in $CMDLINE; do
    case "$part" in
        root=*)
            echo "$CMDLINE"
            exit 0
            ;;
    esac
done

ROOTDEV=$(mountpoint -d /)

# not a mount point?
if [ $? -ne 0 ]; then
    echo "$CMDLINE"
    exit 1
fi

EVENTF="/sys/dev/block/${ROOTDEV}/uevent"

# can happen with e.g. zfs mounts
if [ ! -f "$EVENTF" ]; then
    echo "$CMDLINE"
    exit 0
fi

. "$EVENTF"

if [ -z "$DEVNAME" ]; then
    echo "$CMDLINE"
    exit 1
fi

BDEV=$(realpath -q "/dev/$DEVNAME" 2>/dev/null)

# should not happen
if [ -z "$BDEV" ]; then
    echo "$CMDLINE"
    exit 1
fi

ROOTDEV=

scan_rootdev() {
    [ -n "$ROOTDEV" ] && return 0

    for f in "$1"/*; do
        [ -b "$f" ] || continue
        MAPNAME=$(realpath -q "$f" 2>/dev/null)
        [ -n "$MAPNAME" ] || continue
        if [ "$MAPNAME" = "$BDEV" ]; then
            if [ -n "$2" ]; then
                ROOTDEV="$2=$(basename $f)"
            else
                ROOTDEV="$f"
            fi
            break
        fi
    done
}

# first try partuuid, as that can be handled by
# the kernel (in this format) even without initramfs
scan_rootdev /dev/disk/by-partuuid PARTUUID

# next try mapper devices, which need an initramfs
# and are identified by a full path in /dev/mapper
scan_rootdev /dev/mapper

# last try uuid, which is a part of the filesystem
# and thus only works when you do have an initramfs
scan_rootdev /dev/disk/by-uuid UUID

# prepend as necessary
if [ -n "$CMDLINE" -a -n "$ROOTDEV" ]; then
    echo "root=$ROOTDEV $CMDLINE"
elif [ -n "$ROOTDEV" ]; then
    echo "root=$ROOTDEV"
else
    echo "$CMDLINE"
fi

exit 0
