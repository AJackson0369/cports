Upstream backport.

diff --git a/data/pam/dinit-userservd b/data/pam/dinit-userservd
new file mode 100644
index 0000000..110f131
--- /dev/null
+++ b/data/pam/dinit-userservd
@@ -0,0 +1,4 @@
+session		required	pam_loginuid.so
+session		optional	pam_keyinit.so force revoke
+session		optional	pam_umask.so usergroups umask=022
+session		required	pam_limits.so
diff --git a/meson.build b/meson.build
index 67af6a9..e9bd0b0 100644
--- a/meson.build
+++ b/meson.build
@@ -12,6 +12,8 @@ project(
 cpp = meson.get_compiler('cpp')
 
 pam_dep = dependency('pam', required: true)
+# could be openpam, in which case pam_misc is not present
+pam_misc_dep = dependency('pam_misc', required: false)
 rt_dep = cpp.find_library('rt', required: false)
 
 scdoc_dep = dependency('scdoc', version: '>=1.10', required: get_option('man'))
@@ -23,6 +25,8 @@ conf_data.set_quoted('CONF_PATH', join_paths(
 ))
 conf_data.set10('MANAGE_RUNDIR', get_option('manage_rundir'))
 
+conf_data.set('HAVE_PAM_MISC', pam_misc_dep.found())
+
 statepath = join_paths(
     get_option('prefix'), get_option('localstatedir'),
     get_option('statedir')
@@ -47,7 +51,7 @@ daemon = executable(
     'dinit-userservd', daemon_sources,
     include_directories: extra_inc,
     install: true,
-    dependencies: [rt_dep],
+    dependencies: [rt_dep, pam_dep, pam_misc_dep],
     gnu_symbol_visibility: 'hidden'
 )
 
@@ -67,6 +71,12 @@ install_data(
     install_mode: 'rw-r--r--'
 )
 
+install_data(
+    'data/pam/dinit-userservd',
+    install_dir: join_paths(get_option('sysconfdir'), 'pam.d'),
+    install_mode: 'rw-r--r--'
+)
+
 uconf_data = configuration_data()
 
 uconf_data.set('RUN_PATH', get_option('rundir'))
diff --git a/src/dinit_utils.cc b/src/dinit_utils.cc
index d6644bd..e305887 100644
--- a/src/dinit_utils.cc
+++ b/src/dinit_utils.cc
@@ -4,10 +4,22 @@
 #include <grp.h>
 #include <fcntl.h>
 #include <unistd.h>
+#include <paths.h>
 #include <sys/stat.h>
+#include <sys/resource.h>
 
 #include "dinit-userservd.hh"
 
+#include <sys/resource.h>
+#include <security/pam_appl.h>
+#ifdef HAVE_PAM_MISC
+#  include <security/pam_misc.h>
+#  define PAM_CONV_FUNC misc_conv
+#else
+#  include <security/openpam.h>
+#  define PAM_CONV_FUNC openpam_ttyconv
+#endif
+
 bool dinit_boot(session &sess, bool disabled) {
     print_dbg("dinit: boot wait");
     auto pid = fork();
@@ -45,23 +57,119 @@ bool dinit_boot(session &sess, bool disabled) {
     return true;
 }
 
+static bool dpam_setup_groups(pam_handle_t *pamh, struct passwd *pwd) {
+    if (initgroups(pwd->pw_name, pwd->pw_gid) != 0) {
+        perror("dinit: failed to set supplementary groups");
+        return false;
+    }
+    auto pst = pam_setcred(pamh, PAM_ESTABLISH_CRED);
+    if (pst != PAM_SUCCESS) {
+        perror("dinit: pam_setcred");
+        pam_end(pamh, pst);
+        return false;
+    }
+    return true;
+}
+
+static pam_handle_t *dpam_begin(struct passwd *pwd) {
+    pam_conv cnv = {
+        PAM_CONV_FUNC,
+        nullptr
+    };
+    pam_handle_t *pamh = nullptr;
+    auto pst = pam_start(DPAM_SERVICE, pwd->pw_name, &cnv, &pamh);
+    if (pst != PAM_SUCCESS) {
+        perror("dinit: pam_start");
+        return nullptr;
+    }
+    /* set the originating user while at it */
+    pst = pam_set_item(pamh, PAM_RUSER, "root");
+    if (pst != PAM_SUCCESS) {
+        perror("dinit: pam_set_item(PAM_RUSER)");
+        pam_end(pamh, pst);
+        return nullptr;
+    }
+    if (!dpam_setup_groups(pamh, pwd)) {
+        return nullptr;
+    }
+    return pamh;
+}
+
+static void sanitize_limits() {
+    struct rlimit l{0, 0};
+
+    setrlimit(RLIMIT_NICE, &l);
+    setrlimit(RLIMIT_RTPRIO, &l);
+
+    l.rlim_cur = RLIM_INFINITY;
+    l.rlim_max = RLIM_INFINITY;
+    setrlimit(RLIMIT_FSIZE, &l);
+    setrlimit(RLIMIT_AS, &l);
+
+    getrlimit(RLIMIT_NOFILE, &l);
+    if (l.rlim_cur != FD_SETSIZE) {
+        l.rlim_cur = FD_SETSIZE;
+        setrlimit(RLIMIT_NOFILE, &l);
+    }
+}
+
+static bool dpam_open(pam_handle_t *pamh) {
+    /* before opening session, do not rely on just PAM and sanitize a bit */
+    sanitize_limits();
+
+    auto pst = pam_open_session(pamh, 0);
+    if (pst != PAM_SUCCESS) {
+        perror("dinit: pam_open_session");
+        pam_setcred(pamh, PAM_DELETE_CRED | PAM_SILENT);
+        pam_end(pamh, pst);
+        return false;
+    }
+    return true;
+}
+
+static bool dpam_setup(pam_handle_t *pamh, struct passwd *pwd) {
+    if (!dpam_open(pamh)) {
+        return false;
+    }
+    /* change identity */
+    if (setgid(pwd->pw_uid) != 0) {
+        perror("dinit: failed to set gid");
+        return false;
+    }
+    if (setuid(pwd->pw_gid) != 0) {
+        perror("dinit: failed to set uid");
+        return false;
+    }
+    return true;
+}
+
+static void dpam_finalize(pam_handle_t *pamh) {
+    if (!pamh) {
+        /* when not doing PAM, at least restore umask to user default,
+         * otherwise the PAM configuration will do it (pam_umask.so)
+         */
+        umask(022);
+        return;
+    }
+    /* end with success */
+    pam_end(pamh, PAM_SUCCESS | PAM_DATA_SILENT);
+}
+
 void dinit_child(session &sess, char const *pipenum) {
+    auto *pw = getpwuid(sess.uid);
+    if (!pw) {
+        perror("dinit: getpwuid failed");
+        return;
+    }
+    if ((pw->pw_uid != sess.uid) || (pw->pw_gid != sess.gid)) {
+        fputs("dinit: uid/gid does not match user", stderr);
+        return;
+    }
+    pam_handle_t *pamh = nullptr;
     if (getuid() == 0) {
-        auto *pw = getpwuid(sess.uid);
-        if (!pw) {
-            perror("dinit: getpwuid failed");
-            return;
-        }
-        if (setgid(sess.gid) != 0) {
-            perror("dinit: failed to set gid");
-            return;
-        }
-        if (initgroups(pw->pw_name, sess.gid) != 0) {
-            perror("dinit: failed to set supplementary groups");
-            return;
-        }
-        if (setuid(sess.uid) != 0) {
-            perror("dinit: failed to set uid");
+        /* setup pam session */
+        pamh = dpam_begin(pw);
+        if (!pamh || !dpam_setup(pamh, pw)) {
             return;
         }
     }
@@ -168,12 +276,60 @@ bdir_done:
         }
     }
     argc = nexec;
-    /* environment starts here */
-    add_str("HOME=", sess.homedir);
-    add_str("UID=", sess.uids);
-    add_str("GID=", sess.gids);
-    add_str("PATH=/usr/local/bin:/usr/bin:/bin");
-    if (sess.rundir[0]) {
+    /* pam env vars take preference */
+    bool have_env_shell   = false, have_env_user   = false,
+         have_env_logname = false, have_env_home   = false,
+         have_env_uid     = false, have_env_gid    = false,
+         have_env_path    = false, have_env_rundir = false;
+    /* get them and loop */
+    if (pamh) {
+        /* this is a copy, but we exec so it's fine to leak */
+        char **penv = pam_getenvlist(pamh);
+        while (penv && *penv) {
+            /* ugly but it's not like putenv actually does anything else */
+            if (!strncmp(*penv, "SHELL=", 6)) {
+                have_env_shell = true;
+            } else if (!strncmp(*penv, "USER=", 5)) {
+                have_env_user = true;
+            } else if (!strncmp(*penv, "LOGNAME=", 8)) {
+                have_env_logname = true;
+            } else if (!strncmp(*penv, "HOME=", 5)) {
+                have_env_home = true;
+            } else if (!strncmp(*penv, "UID=", 4)) {
+                have_env_uid = true;
+            } else if (!strncmp(*penv, "GID=", 4)) {
+                have_env_gid = true;
+            } else if (!strncmp(*penv, "PATH=", 5)) {
+                have_env_path = true;
+            } else if (!strncmp(*penv, "XDG_RUNTIME_DIR=", 16)) {
+                have_env_rundir = true;
+            }
+            add_str(*penv);
+        }
+    }
+    /* add our environment defaults if not already set */
+    if (!have_env_shell) {
+        add_str("SHELL=" _PATH_BSHELL);
+    }
+    if (!have_env_user) {
+        add_str("USER=", pw->pw_name);
+    }
+    if (!have_env_logname) {
+        add_str("LOGNAME=", pw->pw_name);
+    }
+    if (!have_env_home) {
+        add_str("HOME=", sess.homedir);
+    }
+    if (!have_env_uid) {
+        add_str("UID=", sess.uids);
+    }
+    if (!have_env_gid) {
+        add_str("GID=", sess.gids);
+    }
+    if (!have_env_path) {
+        add_str("PATH=" _PATH_DEFPATH);
+    }
+    if (sess.rundir[0] && !have_env_rundir) {
         add_str("XDG_RUNTIME_DIR=", sess.rundir);
     }
     /* make up env and arg arrays */
@@ -193,8 +349,10 @@ bdir_done:
         argp.push_back(nullptr);
     }
     auto *argv = const_cast<char **>(&argp[0]);
-    /* restore umask to user default */
-    umask(022);
+    /* try change directory to home, but do not fail */
+    chdir(sess.homedir);
+    /* finish pam before execing */
+    dpam_finalize(pamh);
     /* fire */
-    execvpe("dinit", argv, argv + argc + 1);
+    execvpe(argv[0], argv, argv + argc + 1);
 }
diff --git a/src/protocol.hh b/src/protocol.hh
index ee42047..a099b78 100644
--- a/src/protocol.hh
+++ b/src/protocol.hh
@@ -15,7 +15,8 @@
 #error "No RUN_PATH is defined"
 #endif
 
-#define SOCK_DIR "dinit-userservd"
+#define DPAM_SERVICE "dinit-userservd"
+#define SOCK_DIR DPAM_SERVICE
 #define DAEMON_SOCK RUN_PATH "/" SOCK_DIR "/control.sock"
 
 /* maximum length of a directory path we can receive */
