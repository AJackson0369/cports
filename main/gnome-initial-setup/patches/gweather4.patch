From 34462d5c6255cd432044a7d9799ac055991b552e Mon Sep 17 00:00:00 2001
From: Will Thompson <will@willthompson.co.uk>
Date: Tue, 4 Jan 2022 12:52:44 +0000
Subject: [PATCH 1/4] timezone: Build against gweather-4.0

GWeather 4.0 removes GWeatherLocationEntry and, as a result, its
dependency on any version of GTK.

For now we just replace this widget with a plain GtkEntry. A subsequent
commit will re-introduce an imported & adjusted copy of GWeatherLocationEntry.

https://gitlab.gnome.org/GNOME/gnome-initial-setup/-/issues/132

Part-of: <https://gitlab.gnome.org/GNOME/gnome-initial-setup/-/merge_requests/133>
---
 .gitignore                                    |  1 +
 .gitlab-ci.yml                                |  4 ++++
 gnome-initial-setup/meson.build               |  2 +-
 .../pages/timezone/gis-timezone-page.c        | 23 ++++++++++---------
 .../pages/timezone/gis-timezone-page.ui       |  2 +-
 subprojects/libgweather.wrap                  |  3 +++
 6 files changed, 22 insertions(+), 13 deletions(-)
 create mode 100644 subprojects/libgweather.wrap

diff --git a/gnome-initial-setup/pages/timezone/gis-timezone-page.c b/gnome-initial-setup/pages/timezone/gis-timezone-page.c
index 573b876b..e0a6d3df 100644
--- a/gnome-initial-setup/pages/timezone/gis-timezone-page.c
+++ b/gnome-initial-setup/pages/timezone/gis-timezone-page.c
@@ -39,7 +39,6 @@
 #include <geoclue.h>
 #include <geocode-glib/geocode-glib.h>
 
-#define GWEATHER_I_KNOW_THIS_IS_UNSTABLE
 #include <libgweather/gweather.h>
 
 #include "timedated.h"
@@ -126,20 +125,20 @@ set_location (GisTimezonePage  *page,
 {
   GisTimezonePagePrivate *priv = gis_timezone_page_get_instance_private (page);
 
-  g_clear_pointer (&priv->current_location, gweather_location_unref);
+  g_clear_object (&priv->current_location);
 
   gtk_widget_set_visible (priv->search_overlay, (location == NULL));
   gis_page_set_complete (GIS_PAGE (page), (location != NULL));
 
   if (location)
     {
-      GWeatherTimezone *zone;
+      GTimeZone *zone;
       const char *tzid;
 
-      priv->current_location = gweather_location_ref (location);
+      priv->current_location = g_object_ref (location);
 
       zone = gweather_location_get_timezone (location);
-      tzid = gweather_timezone_get_tzid (zone);
+      tzid = g_time_zone_get_identifier (zone);
 
       cc_timezone_map_set_timezone (CC_TIMEZONE_MAP (priv->map), tzid);
 
@@ -158,18 +157,18 @@ on_location_notify (GClueSimple *simple,
   GisTimezonePagePrivate *priv = gis_timezone_page_get_instance_private (page);
   GClueLocation *location;
   gdouble latitude, longitude;
-  GWeatherLocation *glocation = NULL;
+  g_autoptr(GWeatherLocation) world = gweather_location_get_world ();
+  g_autoptr(GWeatherLocation) glocation = NULL;
 
   location = gclue_simple_get_location (simple);
 
   latitude = gclue_location_get_latitude (location);
   longitude = gclue_location_get_longitude (location);
 
-  glocation = gweather_location_find_nearest_city (NULL, latitude, longitude);
+  glocation = gweather_location_find_nearest_city (world, latitude, longitude);
   priv->in_geoclue_callback = TRUE;
   set_location (page, glocation);
   priv->in_geoclue_callback = FALSE;
-  gweather_location_unref (glocation);
 }
 
 static void
@@ -229,12 +228,13 @@ entry_text_changed (GtkEditable *editable,
   priv->search_entry_text_changed_id = 0;
 }
 
+#if 0
 static void
 entry_location_changed (GObject *object, GParamSpec *param, GisTimezonePage *page)
 {
   GisTimezonePagePrivate *priv = gis_timezone_page_get_instance_private (page);
   GWeatherLocationEntry *entry = GWEATHER_LOCATION_ENTRY (object);
-  GWeatherLocation *location;
+  g_autoptr(GWeatherLocation) location = NULL;
 
   location = gweather_location_entry_get_location (entry);
   if (!location)
@@ -243,9 +243,8 @@ entry_location_changed (GObject *object, GParamSpec *param, GisTimezonePage *pag
   priv->in_search = TRUE;
   set_location (page, location);
   priv->in_search = FALSE;
-
-  gweather_location_unref (location);
 }
+#endif
 
 #define GETTEXT_PACKAGE_TIMEZONES "gnome-control-center-2.0-timezones"
 
@@ -447,8 +446,10 @@ gis_timezone_page_constructed (GObject *object)
   priv->search_entry_text_changed_id =
       g_signal_connect (priv->search_entry, "changed",
                         G_CALLBACK (entry_text_changed), page);
+#if 0
   g_signal_connect (priv->search_entry, "notify::location",
                     G_CALLBACK (entry_location_changed), page);
+#endif
   g_signal_connect (priv->search_entry, "map",
                     G_CALLBACK (entry_mapped), page);
   g_signal_connect (priv->map, "location-changed",
diff --git a/gnome-initial-setup/pages/timezone/gis-timezone-page.ui b/gnome-initial-setup/pages/timezone/gis-timezone-page.ui
index 07fc3520..1f81d3ed 100644
--- a/gnome-initial-setup/pages/timezone/gis-timezone-page.ui
+++ b/gnome-initial-setup/pages/timezone/gis-timezone-page.ui
@@ -28,7 +28,7 @@
             <property name="orientation">vertical</property>
             <property name="spacing">14</property>
             <child>
-              <object class="GWeatherLocationEntry" id="search_entry">
+              <object class="GtkEntry" id="search_entry">
                 <property name="visible">True</property>
                 <property name="halign">center</property>
                 <property name="max-width-chars">55</property>
diff --git a/subprojects/libgweather.wrap b/subprojects/libgweather.wrap
new file mode 100644
index 00000000..6d36c28e
--- /dev/null
+++ b/subprojects/libgweather.wrap
@@ -0,0 +1,3 @@
+[wrap-git]
+url = https://gitlab.gnome.org/GNOME/libgweather.git
+revision = main
-- 
GitLab


From 7cb6d689d84750291b35ce2442157472fc8596fc Mon Sep 17 00:00:00 2001
From: Will Thompson <will@willthompson.co.uk>
Date: Wed, 29 Dec 2021 11:05:21 +0000
Subject: [PATCH 2/4] timezone: Import GWeatherLocationEntry

These files are taken from libgweather at commit 7d98cfad ("docs: Update
the README file") which is the last commit before they were removed in
commit 6352a74f ("Remove GTK3 widgets").

The widget will be re-namespaced and added to the build in a subsequent
commit.

https://gitlab.gnome.org/GNOME/gnome-initial-setup/-/issues/132

Part-of: <https://gitlab.gnome.org/GNOME/gnome-initial-setup/-/merge_requests/133>
---
 .../pages/timezone/gis-location-entry.c       | 860 ++++++++++++++++++
 .../pages/timezone/gis-location-entry.h       |  57 ++
 2 files changed, 917 insertions(+)
 create mode 100644 gnome-initial-setup/pages/timezone/gis-location-entry.c
 create mode 100644 gnome-initial-setup/pages/timezone/gis-location-entry.h

diff --git a/gnome-initial-setup/pages/timezone/gis-location-entry.c b/gnome-initial-setup/pages/timezone/gis-location-entry.c
new file mode 100644
index 00000000..d0a4e2b4
--- /dev/null
+++ b/gnome-initial-setup/pages/timezone/gis-location-entry.c
@@ -0,0 +1,860 @@
+/* gweather-location-entry.c - Location-selecting text entry
+ *
+ * SPDX-FileCopyrightText: 2008, Red Hat, Inc.
+ * SPDX-License-Identifier: LGPL-2.1-or-later
+ */
+
+#include "config.h"
+
+#include "gweather-location-entry.h"
+
+#include "gweather-private.h"
+
+#include <string.h>
+#include <gio/gio.h>
+#include <geocode-glib/geocode-glib.h>
+
+/**
+ * GWeatherLocationEntry:
+ *
+ * A subclass of [class@Gtk.SearchEntry] that provides autocompletion on
+ * [struct@GWeather.Location]s.
+ */
+
+struct _GWeatherLocationEntryPrivate {
+    GWeatherLocation *location;
+    GWeatherLocation *top;
+    gboolean          show_named_timezones;
+    gboolean          custom_text;
+    GCancellable     *cancellable;
+    GtkTreeModel     *model;
+};
+
+G_DEFINE_TYPE_WITH_PRIVATE (GWeatherLocationEntry, gweather_location_entry, GTK_TYPE_SEARCH_ENTRY)
+
+enum {
+    PROP_0,
+
+    PROP_TOP,
+    PROP_SHOW_NAMED_TIMEZONES,
+    PROP_LOCATION,
+
+    LAST_PROP
+};
+
+static void set_property (GObject *object, guint prop_id,
+			  const GValue *value, GParamSpec *pspec);
+static void get_property (GObject *object, guint prop_id,
+			  GValue *value, GParamSpec *pspec);
+
+static void set_location_internal (GWeatherLocationEntry *entry,
+				   GtkTreeModel          *model,
+				   GtkTreeIter           *iter,
+				   GWeatherLocation      *loc);
+static void
+fill_location_entry_model (GtkListStore *store, GWeatherLocation *loc,
+			   const char *parent_display_name,
+			   const char *parent_sort_local_name,
+			   const char *parent_compare_local_name,
+			   const char *parent_compare_english_name,
+			   gboolean show_named_timezones);
+
+enum LOC
+{
+    LOC_GWEATHER_LOCATION_ENTRY_COL_DISPLAY_NAME = 0,
+    LOC_GWEATHER_LOCATION_ENTRY_COL_LOCATION,
+    LOC_GWEATHER_LOCATION_ENTRY_COL_LOCAL_SORT_NAME,
+    LOC_GWEATHER_LOCATION_ENTRY_COL_LOCAL_COMPARE_NAME,
+    LOC_GWEATHER_LOCATION_ENTRY_COL_ENGLISH_COMPARE_NAME,
+    LOC_GWEATHER_LOCATION_ENTRY_NUM_COLUMNS
+};
+
+enum PLACE
+{
+    PLACE_GWEATHER_LOCATION_ENTRY_COL_DISPLAY_NAME = 0,
+    PLACE_GWEATHER_LOCATION_ENTRY_COL_PLACE,
+    PLACE_GWEATHER_LOCATION_ENTRY_COL_LOCAL_SORT_NAME,
+    PLACE_GWEATHER_LOCATION_ENTRY_COL_LOCAL_COMPARE_NAME
+};
+
+static gboolean matcher (GtkEntryCompletion *completion, const char *key,
+			 GtkTreeIter *iter, gpointer user_data);
+static gboolean match_selected (GtkEntryCompletion *completion,
+				GtkTreeModel       *model,
+				GtkTreeIter        *iter,
+				gpointer            entry);
+static void     entry_changed (GWeatherLocationEntry *entry);
+static void _no_matches (GtkEntryCompletion *completion, GWeatherLocationEntry *entry);
+
+static void
+gweather_location_entry_init (GWeatherLocationEntry *entry)
+{
+    GtkEntryCompletion *completion;
+    GWeatherLocationEntryPrivate *priv;
+
+    priv = entry->priv = gweather_location_entry_get_instance_private (entry);
+
+    completion = gtk_entry_completion_new ();
+
+    gtk_entry_completion_set_popup_set_width (completion, FALSE);
+    gtk_entry_completion_set_text_column (completion, LOC_GWEATHER_LOCATION_ENTRY_COL_DISPLAY_NAME);
+    gtk_entry_completion_set_match_func (completion, matcher, NULL, NULL);
+    gtk_entry_completion_set_inline_completion (completion, TRUE);
+
+    g_signal_connect (completion, "match-selected",
+		      G_CALLBACK (match_selected), entry);
+
+    g_signal_connect (completion, "no-matches",
+                      G_CALLBACK (_no_matches), entry);
+
+    gtk_entry_set_completion (GTK_ENTRY (entry), completion);
+    g_object_unref (completion);
+
+    priv->custom_text = FALSE;
+    g_signal_connect (entry, "changed",
+		      G_CALLBACK (entry_changed), NULL);
+}
+
+static void
+finalize (GObject *object)
+{
+    GWeatherLocationEntry *entry;
+    GWeatherLocationEntryPrivate *priv;
+
+    entry = GWEATHER_LOCATION_ENTRY (object);
+    priv = entry->priv;
+
+    if (priv->location)
+	gweather_location_unref (priv->location);
+    if (priv->top)
+	gweather_location_unref (priv->top);
+    if (priv->model)
+        g_object_unref (priv->model);
+
+    G_OBJECT_CLASS (gweather_location_entry_parent_class)->finalize (object);
+}
+
+static void
+dispose (GObject *object)
+{
+    GWeatherLocationEntry *entry;
+    GWeatherLocationEntryPrivate *priv;
+
+    entry = GWEATHER_LOCATION_ENTRY (object);
+    priv = entry->priv;
+
+    if (priv->cancellable) {
+        g_cancellable_cancel (priv->cancellable);
+        g_object_unref (priv->cancellable);
+        priv->cancellable = NULL;
+    }
+
+    G_OBJECT_CLASS (gweather_location_entry_parent_class)->dispose (object);
+}
+
+static int
+tree_compare_local_name (GtkTreeModel *model,
+			 GtkTreeIter  *a,
+			 GtkTreeIter  *b,
+			 gpointer      user_data)
+{
+    g_autofree gchar *name_a = NULL, *name_b = NULL;
+
+    gtk_tree_model_get (model, a,
+			LOC_GWEATHER_LOCATION_ENTRY_COL_LOCAL_SORT_NAME, &name_a,
+			-1);
+    gtk_tree_model_get (model, b,
+			LOC_GWEATHER_LOCATION_ENTRY_COL_LOCAL_SORT_NAME, &name_b,
+			-1);
+
+    return g_utf8_collate (name_a, name_b);
+}
+
+
+static void
+constructed (GObject *object)
+{
+    GWeatherLocationEntry *entry;
+    GtkListStore *store = NULL;
+    GtkEntryCompletion *completion;
+
+    entry = GWEATHER_LOCATION_ENTRY (object);
+
+    if (!entry->priv->top)
+	entry->priv->top = gweather_location_get_world ();
+
+    store = gtk_list_store_new (5, G_TYPE_STRING, GWEATHER_TYPE_LOCATION, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);
+    gtk_tree_sortable_set_default_sort_func (GTK_TREE_SORTABLE (store),
+                                             tree_compare_local_name, NULL, NULL);
+    fill_location_entry_model (store, entry->priv->top, NULL, NULL, NULL, NULL, entry->priv->show_named_timezones);
+
+    entry->priv->model = GTK_TREE_MODEL (store);
+    completion = gtk_entry_get_completion (GTK_ENTRY (entry));
+    gtk_entry_completion_set_match_func (completion, matcher, NULL, NULL);
+    gtk_entry_completion_set_model (completion, GTK_TREE_MODEL (store));
+
+    G_OBJECT_CLASS (gweather_location_entry_parent_class)->constructed (object);
+}
+
+static void
+gweather_location_entry_class_init (GWeatherLocationEntryClass *location_entry_class)
+{
+    GObjectClass *object_class = G_OBJECT_CLASS (location_entry_class);
+
+    object_class->constructed = constructed;
+    object_class->finalize = finalize;
+    object_class->set_property = set_property;
+    object_class->get_property = get_property;
+    object_class->dispose = dispose;
+
+    /* properties */
+    g_object_class_install_property (
+	object_class, PROP_TOP,
+	g_param_spec_boxed ("top",
+			    "Top Location",
+			    "The GWeatherLocation whose children will be used to fill in the entry",
+			    GWEATHER_TYPE_LOCATION,
+			    G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
+    g_object_class_install_property (
+	object_class, PROP_SHOW_NAMED_TIMEZONES,
+	g_param_spec_boolean ("show-named-timezones",
+			      "Show named timezones",
+			      "Whether UTC and other named timezones are shown in the list of locations",
+			      FALSE,
+			      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+    g_object_class_install_property (
+	object_class, PROP_LOCATION,
+	g_param_spec_boxed ("location",
+			    "Location",
+			    "The selected GWeatherLocation",
+			    GWEATHER_TYPE_LOCATION,
+			    G_PARAM_READWRITE));
+}
+
+static void
+set_property (GObject *object, guint prop_id,
+	      const GValue *value, GParamSpec *pspec)
+{
+    GWeatherLocationEntry *entry = GWEATHER_LOCATION_ENTRY (object);
+
+    switch (prop_id) {
+    case PROP_TOP:
+        entry->priv->top = g_value_dup_boxed (value);
+	break;
+    case PROP_SHOW_NAMED_TIMEZONES:
+	entry->priv->show_named_timezones = g_value_get_boolean (value);
+	break;
+    case PROP_LOCATION:
+	gweather_location_entry_set_location (GWEATHER_LOCATION_ENTRY (object),
+					      g_value_get_boxed (value));
+	break;
+    default:
+	G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+	break;
+    }
+}
+
+static void
+get_property (GObject *object, guint prop_id,
+	      GValue *value, GParamSpec *pspec)
+{
+    GWeatherLocationEntry *entry = GWEATHER_LOCATION_ENTRY (object);
+
+    switch (prop_id) {
+    case PROP_SHOW_NAMED_TIMEZONES:
+	g_value_set_boolean (value, entry->priv->show_named_timezones);
+	break;
+    case PROP_LOCATION:
+	g_value_set_boxed (value, entry->priv->location);
+	break;
+    default:
+	G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+	break;
+    }
+}
+
+static void
+entry_changed (GWeatherLocationEntry *entry)
+{
+    GtkEntryCompletion *completion;
+    const gchar *text;
+
+    completion = gtk_entry_get_completion (GTK_ENTRY (entry));
+
+    if (entry->priv->cancellable) {
+        g_cancellable_cancel (entry->priv->cancellable);
+        g_object_unref (entry->priv->cancellable);
+        entry->priv->cancellable = NULL;
+        gtk_entry_completion_delete_action (completion, 0);
+    }
+
+    gtk_entry_completion_set_match_func (gtk_entry_get_completion (GTK_ENTRY (entry)), matcher, NULL, NULL);
+    gtk_entry_completion_set_model (gtk_entry_get_completion (GTK_ENTRY (entry)), entry->priv->model);
+
+    text = gtk_entry_get_text (GTK_ENTRY (entry));
+
+    if (text && *text)
+	entry->priv->custom_text = TRUE;
+    else
+	set_location_internal (entry, NULL, NULL, NULL);
+}
+
+static void
+set_location_internal (GWeatherLocationEntry *entry,
+		       GtkTreeModel          *model,
+		       GtkTreeIter           *iter,
+		       GWeatherLocation      *loc)
+{
+    GWeatherLocationEntryPrivate *priv;
+    char *name;
+
+    priv = entry->priv;
+
+    if (priv->location)
+	gweather_location_unref (priv->location);
+
+    g_assert (iter == NULL || loc == NULL);
+
+    if (iter) {
+	gtk_tree_model_get (model, iter,
+			    LOC_GWEATHER_LOCATION_ENTRY_COL_DISPLAY_NAME, &name,
+			    LOC_GWEATHER_LOCATION_ENTRY_COL_LOCATION, &priv->location,
+			    -1);
+	gtk_entry_set_text (GTK_ENTRY (entry), name);
+	priv->custom_text = FALSE;
+	g_free (name);
+    } else if (loc) {
+	priv->location = gweather_location_ref (loc);
+	gtk_entry_set_text (GTK_ENTRY (entry), gweather_location_get_name (loc));
+	priv->custom_text = FALSE;
+    } else {
+	priv->location = NULL;
+	gtk_entry_set_text (GTK_ENTRY (entry), "");
+	priv->custom_text = TRUE;
+    }
+
+    gtk_editable_set_position (GTK_EDITABLE (entry), -1);
+    g_object_notify (G_OBJECT (entry), "location");
+}
+
+/**
+ * gweather_location_entry_set_location:
+ * @entry: a #GWeatherLocationEntry
+ * @loc: (allow-none): a #GWeatherLocation in @entry, or %NULL to
+ * clear @entry
+ *
+ * Sets @entry's location to @loc, and updates the text of the
+ * entry accordingly.
+ * Note that if the database contains a location that compares
+ * equal to @loc, that will be chosen in place of @loc.
+ **/
+void
+gweather_location_entry_set_location (GWeatherLocationEntry *entry,
+				      GWeatherLocation      *loc)
+{
+    GtkEntryCompletion *completion;
+    GtkTreeModel *model;
+    GtkTreeIter iter;
+    GWeatherLocation *cmploc;
+
+    g_return_if_fail (GWEATHER_IS_LOCATION_ENTRY (entry));
+
+    completion = gtk_entry_get_completion (GTK_ENTRY (entry));
+    model = gtk_entry_completion_get_model (completion);
+
+    if (loc == NULL) {
+	set_location_internal (entry, model, NULL, NULL);
+	return;
+    }
+
+    gtk_tree_model_get_iter_first (model, &iter);
+    do {
+	gtk_tree_model_get (model, &iter,
+			    LOC_GWEATHER_LOCATION_ENTRY_COL_LOCATION, &cmploc,
+			    -1);
+	if (gweather_location_equal (loc, cmploc)) {
+	    set_location_internal (entry, model, &iter, NULL);
+	    gweather_location_unref (cmploc);
+	    return;
+	}
+
+	gweather_location_unref (cmploc);
+    } while (gtk_tree_model_iter_next (model, &iter));
+
+    set_location_internal (entry, model, NULL, loc);
+}
+
+/**
+ * gweather_location_entry_get_location:
+ * @entry: a #GWeatherLocationEntry
+ *
+ * Gets the location that was set by a previous call to
+ * gweather_location_entry_set_location() or was selected by the user.
+ *
+ * Return value: (transfer full) (allow-none): the selected location
+ * (which you must unref when you are done with it), or %NULL if no
+ * location is selected.
+ **/
+GWeatherLocation *
+gweather_location_entry_get_location (GWeatherLocationEntry *entry)
+{
+    g_return_val_if_fail (GWEATHER_IS_LOCATION_ENTRY (entry), NULL);
+
+    if (entry->priv->location)
+	return gweather_location_ref (entry->priv->location);
+    else
+	return NULL;
+}
+
+/**
+ * gweather_location_entry_has_custom_text:
+ * @entry: a #GWeatherLocationEntry
+ *
+ * Checks whether or not @entry's text has been modified by the user.
+ * Note that this does not mean that no location is associated with @entry.
+ * gweather_location_entry_get_location() should be used for this.
+ *
+ * Return value: %TRUE if @entry's text was modified by the user, or %FALSE if
+ * it's set to the default text of a location.
+ **/
+gboolean
+gweather_location_entry_has_custom_text (GWeatherLocationEntry *entry)
+{
+    g_return_val_if_fail (GWEATHER_IS_LOCATION_ENTRY (entry), FALSE);
+
+    return entry->priv->custom_text;
+}
+
+/**
+ * gweather_location_entry_set_city:
+ * @entry: a #GWeatherLocationEntry
+ * @city_name: (allow-none): the city name, or %NULL
+ * @code: the METAR station code
+ *
+ * Sets @entry's location to a city with the given @code, and given
+ * @city_name, if non-%NULL. If there is no matching city, sets
+ * @entry's location to %NULL.
+ *
+ * Return value: %TRUE if @entry's location could be set to a matching city,
+ * %FALSE otherwise.
+ **/
+gboolean
+gweather_location_entry_set_city (GWeatherLocationEntry *entry,
+				  const char            *city_name,
+				  const char            *code)
+{
+    GtkEntryCompletion *completion;
+    GtkTreeModel *model;
+    GtkTreeIter iter;
+    GWeatherLocation *cmploc;
+    const char *cmpcode;
+    char *cmpname;
+
+    g_return_val_if_fail (GWEATHER_IS_LOCATION_ENTRY (entry), FALSE);
+    g_return_val_if_fail (code != NULL, FALSE);
+
+    completion = gtk_entry_get_completion (GTK_ENTRY (entry));
+    model = gtk_entry_completion_get_model (completion);
+
+    gtk_tree_model_get_iter_first (model, &iter);
+    do {
+	gtk_tree_model_get (model, &iter,
+			    LOC_GWEATHER_LOCATION_ENTRY_COL_LOCATION, &cmploc,
+			    -1);
+
+	cmpcode = gweather_location_get_code (cmploc);
+	if (!cmpcode || strcmp (cmpcode, code) != 0) {
+	    gweather_location_unref (cmploc);
+	    continue;
+	}
+
+	if (city_name) {
+	    cmpname = gweather_location_get_city_name (cmploc);
+	    if (!cmpname || strcmp (cmpname, city_name) != 0) {
+		gweather_location_unref (cmploc);
+		g_free (cmpname);
+		continue;
+	    }
+	    g_free (cmpname);
+	}
+
+	set_location_internal (entry, model, &iter, NULL);
+	gweather_location_unref (cmploc);
+	return TRUE;
+    } while (gtk_tree_model_iter_next (model, &iter));
+
+    set_location_internal (entry, model, NULL, NULL);
+
+    return FALSE;
+}
+
+static void
+fill_location_entry_model (GtkListStore *store, GWeatherLocation *loc,
+			   const char *parent_display_name,
+			   const char *parent_sort_local_name,
+			   const char *parent_compare_local_name,
+			   const char *parent_compare_english_name,
+			   gboolean show_named_timezones)
+{
+    g_autoptr(GWeatherLocation) child = NULL;
+    char *display_name, *local_sort_name, *local_compare_name, *english_compare_name;
+
+    switch (gweather_location_get_level (loc)) {
+    case GWEATHER_LOCATION_WORLD:
+    case GWEATHER_LOCATION_REGION:
+	/* Ignore these levels of hierarchy; just recurse, passing on
+	 * the names from the parent node.
+	 */
+	while ((child = gweather_location_next_child (loc, child)))
+	    fill_location_entry_model (store, child,
+				       parent_display_name,
+				       parent_sort_local_name,
+				       parent_compare_local_name,
+				       parent_compare_english_name,
+				       show_named_timezones);
+	break;
+
+    case GWEATHER_LOCATION_COUNTRY:
+	/* Recurse, initializing the names to the country name */
+	while ((child = gweather_location_next_child (loc, child)))
+	    fill_location_entry_model (store, child,
+				       gweather_location_get_name (loc),
+				       gweather_location_get_sort_name (loc),
+				       gweather_location_get_sort_name (loc),
+				       gweather_location_get_english_sort_name (loc),
+				       show_named_timezones);
+	break;
+
+    case GWEATHER_LOCATION_ADM1:
+	/* Recurse, adding the ADM1 name to the country name */
+	/* Translators: this is the name of a location followed by a region, for example:
+	 * 'London, United Kingdom'
+	 * You shouldn't need to translate this string unless the language has a different comma.
+	 */
+	display_name = g_strdup_printf (_("%s, %s"), gweather_location_get_name (loc), parent_display_name);
+	local_sort_name = g_strdup_printf ("%s, %s", parent_sort_local_name, gweather_location_get_sort_name (loc));
+	local_compare_name = g_strdup_printf ("%s, %s", gweather_location_get_sort_name (loc), parent_compare_local_name);
+	english_compare_name = g_strdup_printf ("%s, %s", gweather_location_get_english_sort_name (loc), parent_compare_english_name);
+
+	while ((child = gweather_location_next_child (loc, child)))
+	    fill_location_entry_model (store, child,
+				       display_name, local_sort_name, local_compare_name, english_compare_name,
+				       show_named_timezones);
+
+	g_free (display_name);
+	g_free (local_compare_name);
+	g_free (english_compare_name);
+	break;
+
+    case GWEATHER_LOCATION_CITY:
+	/* If there are multiple (<location>) children, we use the one
+	 * closest to the city center.
+	 *
+	 * Locations are already sorted by increasing distance from
+	 * the city.
+	 */
+    case GWEATHER_LOCATION_WEATHER_STATION:
+	/* <location> with no parent <city> */
+	/* Translators: this is the name of a location followed by a region, for example:
+	 * 'London, United Kingdom'
+	 * You shouldn't need to translate this string unless the language has a different comma.
+	 */
+	display_name = g_strdup_printf (_("%s, %s"),
+					gweather_location_get_name (loc), parent_display_name);
+	local_sort_name = g_strdup_printf ("%s, %s",
+					   parent_sort_local_name, gweather_location_get_sort_name (loc));
+	local_compare_name = g_strdup_printf ("%s, %s",
+					      gweather_location_get_sort_name (loc), parent_compare_local_name);
+	english_compare_name = g_strdup_printf ("%s, %s",
+						gweather_location_get_english_sort_name (loc), parent_compare_english_name);
+
+	gtk_list_store_insert_with_values (store, NULL, -1,
+					   LOC_GWEATHER_LOCATION_ENTRY_COL_LOCATION, loc,
+					   LOC_GWEATHER_LOCATION_ENTRY_COL_DISPLAY_NAME, display_name,
+					   LOC_GWEATHER_LOCATION_ENTRY_COL_LOCAL_SORT_NAME, local_sort_name,
+					   LOC_GWEATHER_LOCATION_ENTRY_COL_LOCAL_COMPARE_NAME, local_compare_name,
+					   LOC_GWEATHER_LOCATION_ENTRY_COL_ENGLISH_COMPARE_NAME, english_compare_name,
+					   -1);
+
+	g_free (display_name);
+	g_free (local_compare_name);
+	g_free (english_compare_name);
+	break;
+
+    case GWEATHER_LOCATION_NAMED_TIMEZONE:
+	if (show_named_timezones) {
+	    gtk_list_store_insert_with_values (store, NULL, -1,
+					       LOC_GWEATHER_LOCATION_ENTRY_COL_LOCATION, loc,
+					       LOC_GWEATHER_LOCATION_ENTRY_COL_DISPLAY_NAME, gweather_location_get_name (loc),
+					       LOC_GWEATHER_LOCATION_ENTRY_COL_LOCAL_SORT_NAME, gweather_location_get_sort_name (loc),
+					       LOC_GWEATHER_LOCATION_ENTRY_COL_LOCAL_COMPARE_NAME, gweather_location_get_sort_name (loc),
+					       LOC_GWEATHER_LOCATION_ENTRY_COL_ENGLISH_COMPARE_NAME, gweather_location_get_english_sort_name (loc),
+					       -1);
+	}
+	break;
+
+    case GWEATHER_LOCATION_DETACHED:
+	g_assert_not_reached ();
+    }
+}
+
+static char *
+find_word (const char *full_name, const char *word, int word_len,
+	   gboolean whole_word, gboolean is_first_word)
+{
+    char *p;
+
+    if (word == NULL || *word == '\0')
+        return NULL;
+
+    p = (char *)full_name - 1;
+    while ((p = strchr (p + 1, *word))) {
+	if (strncmp (p, word, word_len) != 0)
+	    continue;
+
+	if (p > (char *)full_name) {
+	    char *prev = g_utf8_prev_char (p);
+
+	    /* Make sure p points to the start of a word */
+	    if (g_unichar_isalpha (g_utf8_get_char (prev)))
+		continue;
+
+	    /* If we're matching the first word of the key, it has to
+	     * match the first word of the location, city, state, or
+	     * country, or the abbreviation (in parenthesis).
+	     * Eg, it either matches the start of the string
+	     * (which we already know it doesn't at this point) or
+	     * it is preceded by the string ", " or "(" (which isn't actually
+	     * a perfect test. FIXME)
+	     */
+	    if (is_first_word) {
+		if (prev == (char *)full_name ||
+		    ((prev - 1 <= full_name && strncmp (prev - 1, ", ", 2) != 0)
+		      && *prev != '('))
+		    continue;
+	    }
+	}
+
+	if (whole_word && g_unichar_isalpha (g_utf8_get_char (p + word_len)))
+	    continue;
+
+	return p;
+    }
+    return NULL;
+}
+
+static gboolean
+match_compare_name (const char *key, const char *name)
+{
+    gboolean is_first_word = TRUE;
+    size_t len;
+
+    /* Ignore whitespace before the string */
+    key += strspn (key, " ");
+
+    /* All but the last word in KEY must match a full word from NAME,
+     * in order (but possibly skipping some words from NAME).
+     */
+    len = strcspn (key, " ");
+    while (key[len]) {
+	name = find_word (name, key, len, TRUE, is_first_word);
+	if (!name)
+	    return FALSE;
+
+	key += len;
+	while (*key && !g_unichar_isalpha (g_utf8_get_char (key)))
+	    key = g_utf8_next_char (key);
+	while (*name && !g_unichar_isalpha (g_utf8_get_char (name)))
+	    name = g_utf8_next_char (name);
+
+	len = strcspn (key, " ");
+	is_first_word = FALSE;
+    }
+
+    /* The last word in KEY must match a prefix of a following word in NAME */
+    if (len == 0) {
+	return TRUE;
+    } else {
+	// if we get here, key[len] == 0, so...
+	g_assert (len == strlen(key));
+	return find_word (name, key, len, FALSE, is_first_word) != NULL;
+    }
+}
+
+static gboolean
+matcher (GtkEntryCompletion *completion, const char *key,
+	 GtkTreeIter *iter, gpointer user_data)
+{
+    char *local_compare_name, *english_compare_name;
+    gboolean match;
+
+    gtk_tree_model_get (gtk_entry_completion_get_model (completion), iter,
+			LOC_GWEATHER_LOCATION_ENTRY_COL_LOCAL_COMPARE_NAME, &local_compare_name,
+			LOC_GWEATHER_LOCATION_ENTRY_COL_ENGLISH_COMPARE_NAME, &english_compare_name,
+			-1);
+
+    match = match_compare_name (key, local_compare_name) ||
+	    match_compare_name (key, english_compare_name) ||
+	    g_ascii_strcasecmp (key, english_compare_name) == 0;
+
+    g_free (local_compare_name);
+    g_free (english_compare_name);
+    return match;
+}
+
+static gboolean
+match_selected (GtkEntryCompletion *completion,
+		GtkTreeModel       *model,
+		GtkTreeIter        *iter,
+		gpointer            entry)
+{
+    GWeatherLocationEntryPrivate *priv;
+
+    priv = ((GWeatherLocationEntry *)entry)->priv;
+
+    if (model != priv->model) {
+	GeocodePlace *place;
+	char *display_name;
+	GeocodeLocation *loc;
+	GWeatherLocation *location;
+	GWeatherLocation *scope = NULL;
+	const char* country_code;
+
+	gtk_tree_model_get (model, iter,
+			    PLACE_GWEATHER_LOCATION_ENTRY_COL_PLACE, &place,
+			    PLACE_GWEATHER_LOCATION_ENTRY_COL_DISPLAY_NAME, &display_name,
+			    -1);
+
+	country_code = geocode_place_get_country_code (place);
+	if (country_code != NULL && gweather_location_get_level (priv->top) == GWEATHER_LOCATION_WORLD)
+	    scope = gweather_location_find_by_country_code (priv->top, country_code);
+	if (!scope)
+	    scope = priv->top;
+
+	loc = geocode_place_get_location (place);
+	location = gweather_location_find_nearest_city (scope, geocode_location_get_latitude (loc), geocode_location_get_longitude (loc));
+
+	location = _gweather_location_new_detached (location, display_name, TRUE,
+						     geocode_location_get_latitude (loc) * M_PI / 180.0,
+						     geocode_location_get_longitude (loc) * M_PI / 180.0);
+
+	set_location_internal (entry, model, NULL, location);
+
+	g_object_unref (place);
+	g_free (display_name);
+    } else {
+	set_location_internal (entry, model, iter, NULL);
+    }
+    return TRUE;
+}
+
+static gboolean
+new_matcher (GtkEntryCompletion *completion, const char *key,
+             GtkTreeIter        *iter,       gpointer    user_data)
+{
+    return TRUE;
+}
+
+static void
+fill_store (gpointer data, gpointer user_data)
+{
+    GeocodePlace *place = GEOCODE_PLACE (data);
+    GeocodeLocation *loc = geocode_place_get_location (place);
+    const char *display_name;
+    char *normalized;
+    char *compare_name;
+
+    display_name = geocode_location_get_description (loc);
+    normalized = g_utf8_normalize (display_name, -1, G_NORMALIZE_ALL);
+    compare_name = g_utf8_casefold (normalized, -1);
+
+    gtk_list_store_insert_with_values (user_data, NULL, -1,
+				       PLACE_GWEATHER_LOCATION_ENTRY_COL_PLACE, place,
+				       PLACE_GWEATHER_LOCATION_ENTRY_COL_DISPLAY_NAME, display_name,
+				       PLACE_GWEATHER_LOCATION_ENTRY_COL_LOCAL_SORT_NAME, compare_name,
+				       PLACE_GWEATHER_LOCATION_ENTRY_COL_LOCAL_COMPARE_NAME, compare_name,
+				       -1);
+
+    g_free (normalized);
+    g_free (compare_name);
+}
+
+static void
+_got_places (GObject      *source_object,
+             GAsyncResult *result,
+             gpointer      user_data)
+{
+    GList *places;
+    GWeatherLocationEntry *self = user_data;
+    GError *error = NULL;
+    GtkListStore *store = NULL;
+    GtkEntryCompletion *completion;
+
+    places = geocode_forward_search_finish (GEOCODE_FORWARD (source_object), result, &error);
+    if (places == NULL) {
+        /* return without touching anything if cancelled (the entry might have been disposed) */
+        if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+            g_clear_error (&error);
+            return;
+        }
+
+        g_clear_error (&error);
+        completion = gtk_entry_get_completion (user_data);
+        gtk_entry_completion_set_match_func (completion, matcher, NULL, NULL);
+        gtk_entry_completion_set_model (completion, self->priv->model);
+        goto out;
+    }
+
+    completion = gtk_entry_get_completion (user_data);
+    store = gtk_list_store_new (5, G_TYPE_STRING, GEOCODE_TYPE_PLACE, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);
+    gtk_tree_sortable_set_default_sort_func (GTK_TREE_SORTABLE (store),
+                                             tree_compare_local_name, NULL, NULL);
+    g_list_foreach (places, fill_store, store);
+    g_list_free (places);
+    gtk_entry_completion_set_match_func (completion, new_matcher, NULL, NULL);
+    gtk_entry_completion_set_model (completion, GTK_TREE_MODEL (store));
+    g_object_unref (store);
+
+ out:
+    gtk_entry_completion_delete_action (completion, 0);
+    g_clear_object (&self->priv->cancellable);
+}
+
+static void
+_no_matches (GtkEntryCompletion *completion, GWeatherLocationEntry *entry) {
+    const gchar *key = gtk_entry_get_text(GTK_ENTRY (entry));
+    GeocodeForward *forward;
+
+    if (entry->priv->cancellable) {
+        g_cancellable_cancel (entry->priv->cancellable);
+        g_object_unref (entry->priv->cancellable);
+        entry->priv->cancellable = NULL;
+    } else {
+        gtk_entry_completion_insert_action_text (completion, 0, _("Loading…"));
+    }
+
+    entry->priv->cancellable = g_cancellable_new ();
+
+    forward = geocode_forward_new_for_string(key);
+    geocode_forward_search_async (forward, entry->priv->cancellable, _got_places, entry);
+}
+
+/**
+ * gweather_location_entry_new:
+ * @top: the top-level location for the entry.
+ *
+ * Creates a new #GWeatherLocationEntry.
+ *
+ * @top will normally be the location returned from
+ * gweather_location_get_world(), but you can create an entry that
+ * only accepts a smaller set of locations if you want.
+ *
+ * Return value: the new #GWeatherLocationEntry
+ **/
+GtkWidget *
+gweather_location_entry_new (GWeatherLocation *top)
+{
+    return g_object_new (GWEATHER_TYPE_LOCATION_ENTRY,
+			 "top", top,
+			 NULL);
+}
diff --git a/gnome-initial-setup/pages/timezone/gis-location-entry.h b/gnome-initial-setup/pages/timezone/gis-location-entry.h
new file mode 100644
index 00000000..ccd606c7
--- /dev/null
+++ b/gnome-initial-setup/pages/timezone/gis-location-entry.h
@@ -0,0 +1,57 @@
+/* gweather-location-entry.h - Location-selecting text entry
+ *
+ * SPDX-FileCopyrightText: 2008, Red Hat, Inc.
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#pragma once
+
+#if !(defined(IN_GWEATHER_H) || defined(GWEATHER_COMPILATION))
+#error "gweather-location-entry.h must not be included individually, include gweather.h instead"
+#endif
+
+#include <gtk/gtk.h>
+#include <libgweather/gweather-location.h>
+
+G_BEGIN_DECLS
+
+typedef struct _GWeatherLocationEntry GWeatherLocationEntry;
+typedef struct _GWeatherLocationEntryClass GWeatherLocationEntryClass;
+typedef struct _GWeatherLocationEntryPrivate GWeatherLocationEntryPrivate;
+
+#define GWEATHER_TYPE_LOCATION_ENTRY            (gweather_location_entry_get_type ())
+#define GWEATHER_LOCATION_ENTRY(object)         (G_TYPE_CHECK_INSTANCE_CAST ((object), GWEATHER_TYPE_LOCATION_ENTRY, GWeatherLocationEntry))
+#define GWEATHER_LOCATION_ENTRY_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GWEATHER_TYPE_LOCATION_ENTRY, GWeatherLocationEntryClass))
+#define GWEATHER_IS_LOCATION_ENTRY(object)      (G_TYPE_CHECK_INSTANCE_TYPE ((object), GWEATHER_TYPE_LOCATION_ENTRY))
+#define GWEATHER_IS_LOCATION_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GWEATHER_TYPE_LOCATION_ENTRY))
+#define GWEATHER_LOCATION_ENTRY_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GWEATHER_TYPE_LOCATION_ENTRY, GWeatherLocationEntryClass))
+
+struct _GWeatherLocationEntry {
+    GtkSearchEntry parent;
+
+    /*< private >*/
+    GWeatherLocationEntryPrivate *priv;
+};
+
+struct _GWeatherLocationEntryClass {
+    GtkSearchEntryClass parent_class;
+};
+
+GWEATHER_AVAILABLE_IN_ALL
+GType                   gweather_location_entry_get_type        (void);
+
+GWEATHER_AVAILABLE_IN_ALL
+GtkWidget *             gweather_location_entry_new             (GWeatherLocation *top);
+GWEATHER_AVAILABLE_IN_ALL
+void                    gweather_location_entry_set_location    (GWeatherLocationEntry *entry,
+                                                                 GWeatherLocation *loc);
+GWEATHER_AVAILABLE_IN_ALL
+GWeatherLocation *      gweather_location_entry_get_location    (GWeatherLocationEntry *entry);
+GWEATHER_AVAILABLE_IN_ALL
+gboolean                gweather_location_entry_has_custom_text (GWeatherLocationEntry *entry);
+GWEATHER_AVAILABLE_IN_ALL
+gboolean                gweather_location_entry_set_city        (GWeatherLocationEntry *entry,
+                                                                 const char *city_name,
+                                                                 const char *code);
+
+G_END_DECLS
-- 
GitLab


From f372682ea4c61a761708f5948f04645a5bdab7b9 Mon Sep 17 00:00:00 2001
From: Will Thompson <will@willthompson.co.uk>
Date: Tue, 4 Jan 2022 13:22:11 +0000
Subject: [PATCH 3/4] timezone: Renamespace LocationEntry, update to
 GWeather-4.0

Superficial changes:

- Changed widget name from GWeatherLocationEntry to GisLocationEntry.
- Adjusted whitespace to compensate for new name (and to consistently
  use spaces, not a mixture of tabs and spaces).
- Added a light dusting of g_autofree/g_auto().

Adapting to GWeather API changes, namely:

- GWeatherLocation is now a GObject rather than a boxed type.
- _gweather_location_new_detached() is gone, and was never public API anyway. Its
  replacement gweather_location_new_detached() accepts slightly different
  arguments and in particular performs the nearest-city lookup itself.

https://gitlab.gnome.org/GNOME/gnome-initial-setup/-/issues/132

Part-of: <https://gitlab.gnome.org/GNOME/gnome-initial-setup/-/merge_requests/133>
---
 .../pages/timezone/gis-location-entry.c       | 739 +++++++++---------
 .../pages/timezone/gis-location-entry.h       |  56 +-
 .../pages/timezone/meson.build                |   2 +
 3 files changed, 389 insertions(+), 408 deletions(-)

diff --git a/gnome-initial-setup/pages/timezone/gis-location-entry.c b/gnome-initial-setup/pages/timezone/gis-location-entry.c
index d0a4e2b4..37b72a5e 100644
--- a/gnome-initial-setup/pages/timezone/gis-location-entry.c
+++ b/gnome-initial-setup/pages/timezone/gis-location-entry.c
@@ -6,22 +6,22 @@
 
 #include "config.h"
 
-#include "gweather-location-entry.h"
-
-#include "gweather-private.h"
+#include "gis-location-entry.h"
 
 #include <string.h>
+#include <glib/gi18n.h>
 #include <gio/gio.h>
 #include <geocode-glib/geocode-glib.h>
 
 /**
- * GWeatherLocationEntry:
+ * GisLocationEntry:
  *
  * A subclass of [class@Gtk.SearchEntry] that provides autocompletion on
  * [struct@GWeather.Location]s.
+ *
  */
 
-struct _GWeatherLocationEntryPrivate {
+struct _GisLocationEntryPrivate {
     GWeatherLocation *location;
     GWeatherLocation *top;
     gboolean          show_named_timezones;
@@ -30,7 +30,7 @@ struct _GWeatherLocationEntryPrivate {
     GtkTreeModel     *model;
 };
 
-G_DEFINE_TYPE_WITH_PRIVATE (GWeatherLocationEntry, gweather_location_entry, GTK_TYPE_SEARCH_ENTRY)
+G_DEFINE_TYPE_WITH_PRIVATE (GisLocationEntry, gis_location_entry, GTK_TYPE_SEARCH_ENTRY)
 
 enum {
     PROP_0,
@@ -43,66 +43,66 @@ enum {
 };
 
 static void set_property (GObject *object, guint prop_id,
-			  const GValue *value, GParamSpec *pspec);
+                          const GValue *value, GParamSpec *pspec);
 static void get_property (GObject *object, guint prop_id,
-			  GValue *value, GParamSpec *pspec);
+                          GValue *value, GParamSpec *pspec);
 
-static void set_location_internal (GWeatherLocationEntry *entry,
-				   GtkTreeModel          *model,
-				   GtkTreeIter           *iter,
-				   GWeatherLocation      *loc);
+static void set_location_internal (GisLocationEntry *entry,
+                                   GtkTreeModel          *model,
+                                   GtkTreeIter           *iter,
+                                   GWeatherLocation      *loc);
 static void
 fill_location_entry_model (GtkListStore *store, GWeatherLocation *loc,
-			   const char *parent_display_name,
-			   const char *parent_sort_local_name,
-			   const char *parent_compare_local_name,
-			   const char *parent_compare_english_name,
-			   gboolean show_named_timezones);
+                           const char *parent_display_name,
+                           const char *parent_sort_local_name,
+                           const char *parent_compare_local_name,
+                           const char *parent_compare_english_name,
+                           gboolean show_named_timezones);
 
 enum LOC
 {
-    LOC_GWEATHER_LOCATION_ENTRY_COL_DISPLAY_NAME = 0,
-    LOC_GWEATHER_LOCATION_ENTRY_COL_LOCATION,
-    LOC_GWEATHER_LOCATION_ENTRY_COL_LOCAL_SORT_NAME,
-    LOC_GWEATHER_LOCATION_ENTRY_COL_LOCAL_COMPARE_NAME,
-    LOC_GWEATHER_LOCATION_ENTRY_COL_ENGLISH_COMPARE_NAME,
-    LOC_GWEATHER_LOCATION_ENTRY_NUM_COLUMNS
+    LOC_GIS_LOCATION_ENTRY_COL_DISPLAY_NAME = 0,
+    LOC_GIS_LOCATION_ENTRY_COL_LOCATION,
+    LOC_GIS_LOCATION_ENTRY_COL_LOCAL_SORT_NAME,
+    LOC_GIS_LOCATION_ENTRY_COL_LOCAL_COMPARE_NAME,
+    LOC_GIS_LOCATION_ENTRY_COL_ENGLISH_COMPARE_NAME,
+    LOC_GIS_LOCATION_ENTRY_NUM_COLUMNS
 };
 
 enum PLACE
 {
-    PLACE_GWEATHER_LOCATION_ENTRY_COL_DISPLAY_NAME = 0,
-    PLACE_GWEATHER_LOCATION_ENTRY_COL_PLACE,
-    PLACE_GWEATHER_LOCATION_ENTRY_COL_LOCAL_SORT_NAME,
-    PLACE_GWEATHER_LOCATION_ENTRY_COL_LOCAL_COMPARE_NAME
+    PLACE_GIS_LOCATION_ENTRY_COL_DISPLAY_NAME = 0,
+    PLACE_GIS_LOCATION_ENTRY_COL_PLACE,
+    PLACE_GIS_LOCATION_ENTRY_COL_LOCAL_SORT_NAME,
+    PLACE_GIS_LOCATION_ENTRY_COL_LOCAL_COMPARE_NAME
 };
 
 static gboolean matcher (GtkEntryCompletion *completion, const char *key,
-			 GtkTreeIter *iter, gpointer user_data);
+                         GtkTreeIter *iter, gpointer user_data);
 static gboolean match_selected (GtkEntryCompletion *completion,
-				GtkTreeModel       *model,
-				GtkTreeIter        *iter,
-				gpointer            entry);
-static void     entry_changed (GWeatherLocationEntry *entry);
-static void _no_matches (GtkEntryCompletion *completion, GWeatherLocationEntry *entry);
+                                GtkTreeModel       *model,
+                                GtkTreeIter        *iter,
+                                gpointer            entry);
+static void     entry_changed (GisLocationEntry *entry);
+static void _no_matches (GtkEntryCompletion *completion, GisLocationEntry *entry);
 
 static void
-gweather_location_entry_init (GWeatherLocationEntry *entry)
+gis_location_entry_init (GisLocationEntry *entry)
 {
     GtkEntryCompletion *completion;
-    GWeatherLocationEntryPrivate *priv;
+    GisLocationEntryPrivate *priv;
 
-    priv = entry->priv = gweather_location_entry_get_instance_private (entry);
+    priv = entry->priv = gis_location_entry_get_instance_private (entry);
 
     completion = gtk_entry_completion_new ();
 
     gtk_entry_completion_set_popup_set_width (completion, FALSE);
-    gtk_entry_completion_set_text_column (completion, LOC_GWEATHER_LOCATION_ENTRY_COL_DISPLAY_NAME);
+    gtk_entry_completion_set_text_column (completion, LOC_GIS_LOCATION_ENTRY_COL_DISPLAY_NAME);
     gtk_entry_completion_set_match_func (completion, matcher, NULL, NULL);
     gtk_entry_completion_set_inline_completion (completion, TRUE);
 
     g_signal_connect (completion, "match-selected",
-		      G_CALLBACK (match_selected), entry);
+                      G_CALLBACK (match_selected), entry);
 
     g_signal_connect (completion, "no-matches",
                       G_CALLBACK (_no_matches), entry);
@@ -112,35 +112,32 @@ gweather_location_entry_init (GWeatherLocationEntry *entry)
 
     priv->custom_text = FALSE;
     g_signal_connect (entry, "changed",
-		      G_CALLBACK (entry_changed), NULL);
+                      G_CALLBACK (entry_changed), NULL);
 }
 
 static void
 finalize (GObject *object)
 {
-    GWeatherLocationEntry *entry;
-    GWeatherLocationEntryPrivate *priv;
+    GisLocationEntry *entry;
+    GisLocationEntryPrivate *priv;
 
-    entry = GWEATHER_LOCATION_ENTRY (object);
+    entry = GIS_LOCATION_ENTRY (object);
     priv = entry->priv;
 
-    if (priv->location)
-	gweather_location_unref (priv->location);
-    if (priv->top)
-	gweather_location_unref (priv->top);
-    if (priv->model)
-        g_object_unref (priv->model);
+    g_clear_object (&priv->location);
+    g_clear_object (&priv->top);
+    g_clear_object (&priv->model);
 
-    G_OBJECT_CLASS (gweather_location_entry_parent_class)->finalize (object);
+    G_OBJECT_CLASS (gis_location_entry_parent_class)->finalize (object);
 }
 
 static void
 dispose (GObject *object)
 {
-    GWeatherLocationEntry *entry;
-    GWeatherLocationEntryPrivate *priv;
+    GisLocationEntry *entry;
+    GisLocationEntryPrivate *priv;
 
-    entry = GWEATHER_LOCATION_ENTRY (object);
+    entry = GIS_LOCATION_ENTRY (object);
     priv = entry->priv;
 
     if (priv->cancellable) {
@@ -149,23 +146,23 @@ dispose (GObject *object)
         priv->cancellable = NULL;
     }
 
-    G_OBJECT_CLASS (gweather_location_entry_parent_class)->dispose (object);
+    G_OBJECT_CLASS (gis_location_entry_parent_class)->dispose (object);
 }
 
 static int
 tree_compare_local_name (GtkTreeModel *model,
-			 GtkTreeIter  *a,
-			 GtkTreeIter  *b,
-			 gpointer      user_data)
+                         GtkTreeIter  *a,
+                         GtkTreeIter  *b,
+                         gpointer      user_data)
 {
     g_autofree gchar *name_a = NULL, *name_b = NULL;
 
     gtk_tree_model_get (model, a,
-			LOC_GWEATHER_LOCATION_ENTRY_COL_LOCAL_SORT_NAME, &name_a,
-			-1);
+                        LOC_GIS_LOCATION_ENTRY_COL_LOCAL_SORT_NAME, &name_a,
+                        -1);
     gtk_tree_model_get (model, b,
-			LOC_GWEATHER_LOCATION_ENTRY_COL_LOCAL_SORT_NAME, &name_b,
-			-1);
+                        LOC_GIS_LOCATION_ENTRY_COL_LOCAL_SORT_NAME, &name_b,
+                        -1);
 
     return g_utf8_collate (name_a, name_b);
 }
@@ -174,14 +171,14 @@ tree_compare_local_name (GtkTreeModel *model,
 static void
 constructed (GObject *object)
 {
-    GWeatherLocationEntry *entry;
+    GisLocationEntry *entry;
     GtkListStore *store = NULL;
     GtkEntryCompletion *completion;
 
-    entry = GWEATHER_LOCATION_ENTRY (object);
+    entry = GIS_LOCATION_ENTRY (object);
 
     if (!entry->priv->top)
-	entry->priv->top = gweather_location_get_world ();
+        entry->priv->top = gweather_location_get_world ();
 
     store = gtk_list_store_new (5, G_TYPE_STRING, GWEATHER_TYPE_LOCATION, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);
     gtk_tree_sortable_set_default_sort_func (GTK_TREE_SORTABLE (store),
@@ -193,11 +190,11 @@ constructed (GObject *object)
     gtk_entry_completion_set_match_func (completion, matcher, NULL, NULL);
     gtk_entry_completion_set_model (completion, GTK_TREE_MODEL (store));
 
-    G_OBJECT_CLASS (gweather_location_entry_parent_class)->constructed (object);
+    G_OBJECT_CLASS (gis_location_entry_parent_class)->constructed (object);
 }
 
 static void
-gweather_location_entry_class_init (GWeatherLocationEntryClass *location_entry_class)
+gis_location_entry_class_init (GisLocationEntryClass *location_entry_class)
 {
     GObjectClass *object_class = G_OBJECT_CLASS (location_entry_class);
 
@@ -209,72 +206,72 @@ gweather_location_entry_class_init (GWeatherLocationEntryClass *location_entry_c
 
     /* properties */
     g_object_class_install_property (
-	object_class, PROP_TOP,
-	g_param_spec_boxed ("top",
-			    "Top Location",
-			    "The GWeatherLocation whose children will be used to fill in the entry",
-			    GWEATHER_TYPE_LOCATION,
-			    G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
+        object_class, PROP_TOP,
+        g_param_spec_object ("top",
+                             "Top Location",
+                             "The GWeatherLocation whose children will be used to fill in the entry",
+                             GWEATHER_TYPE_LOCATION,
+                             G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
     g_object_class_install_property (
-	object_class, PROP_SHOW_NAMED_TIMEZONES,
-	g_param_spec_boolean ("show-named-timezones",
-			      "Show named timezones",
-			      "Whether UTC and other named timezones are shown in the list of locations",
-			      FALSE,
-			      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+        object_class, PROP_SHOW_NAMED_TIMEZONES,
+        g_param_spec_boolean ("show-named-timezones",
+                              "Show named timezones",
+                              "Whether UTC and other named timezones are shown in the list of locations",
+                              FALSE,
+                              G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
     g_object_class_install_property (
-	object_class, PROP_LOCATION,
-	g_param_spec_boxed ("location",
-			    "Location",
-			    "The selected GWeatherLocation",
-			    GWEATHER_TYPE_LOCATION,
-			    G_PARAM_READWRITE));
+        object_class, PROP_LOCATION,
+        g_param_spec_object ("location",
+                             "Location",
+                             "The selected GWeatherLocation",
+                             GWEATHER_TYPE_LOCATION,
+                             G_PARAM_READWRITE));
 }
 
 static void
 set_property (GObject *object, guint prop_id,
-	      const GValue *value, GParamSpec *pspec)
+              const GValue *value, GParamSpec *pspec)
 {
-    GWeatherLocationEntry *entry = GWEATHER_LOCATION_ENTRY (object);
+    GisLocationEntry *entry = GIS_LOCATION_ENTRY (object);
 
     switch (prop_id) {
     case PROP_TOP:
-        entry->priv->top = g_value_dup_boxed (value);
-	break;
+        entry->priv->top = g_value_dup_object (value);
+        break;
     case PROP_SHOW_NAMED_TIMEZONES:
-	entry->priv->show_named_timezones = g_value_get_boolean (value);
-	break;
+        entry->priv->show_named_timezones = g_value_get_boolean (value);
+        break;
     case PROP_LOCATION:
-	gweather_location_entry_set_location (GWEATHER_LOCATION_ENTRY (object),
-					      g_value_get_boxed (value));
-	break;
+        gis_location_entry_set_location (GIS_LOCATION_ENTRY (object),
+                                         g_value_get_object (value));
+        break;
     default:
-	G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-	break;
+        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+        break;
     }
 }
 
 static void
 get_property (GObject *object, guint prop_id,
-	      GValue *value, GParamSpec *pspec)
+              GValue *value, GParamSpec *pspec)
 {
-    GWeatherLocationEntry *entry = GWEATHER_LOCATION_ENTRY (object);
+    GisLocationEntry *entry = GIS_LOCATION_ENTRY (object);
 
     switch (prop_id) {
     case PROP_SHOW_NAMED_TIMEZONES:
-	g_value_set_boolean (value, entry->priv->show_named_timezones);
-	break;
+        g_value_set_boolean (value, entry->priv->show_named_timezones);
+        break;
     case PROP_LOCATION:
-	g_value_set_boxed (value, entry->priv->location);
-	break;
+        g_value_set_object (value, entry->priv->location);
+        break;
     default:
-	G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-	break;
+        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+        break;
     }
 }
 
 static void
-entry_changed (GWeatherLocationEntry *entry)
+entry_changed (GisLocationEntry *entry)
 {
     GtkEntryCompletion *completion;
     const gchar *text;
@@ -294,43 +291,42 @@ entry_changed (GWeatherLocationEntry *entry)
     text = gtk_entry_get_text (GTK_ENTRY (entry));
 
     if (text && *text)
-	entry->priv->custom_text = TRUE;
+        entry->priv->custom_text = TRUE;
     else
-	set_location_internal (entry, NULL, NULL, NULL);
+        set_location_internal (entry, NULL, NULL, NULL);
 }
 
 static void
-set_location_internal (GWeatherLocationEntry *entry,
-		       GtkTreeModel          *model,
-		       GtkTreeIter           *iter,
-		       GWeatherLocation      *loc)
+set_location_internal (GisLocationEntry *entry,
+                       GtkTreeModel     *model,
+                       GtkTreeIter      *iter,
+                       GWeatherLocation *loc)
 {
-    GWeatherLocationEntryPrivate *priv;
+    GisLocationEntryPrivate *priv;
     char *name;
 
     priv = entry->priv;
 
-    if (priv->location)
-	gweather_location_unref (priv->location);
+    g_clear_object (&priv->location);
 
     g_assert (iter == NULL || loc == NULL);
 
     if (iter) {
-	gtk_tree_model_get (model, iter,
-			    LOC_GWEATHER_LOCATION_ENTRY_COL_DISPLAY_NAME, &name,
-			    LOC_GWEATHER_LOCATION_ENTRY_COL_LOCATION, &priv->location,
-			    -1);
-	gtk_entry_set_text (GTK_ENTRY (entry), name);
-	priv->custom_text = FALSE;
-	g_free (name);
+        gtk_tree_model_get (model, iter,
+                            LOC_GIS_LOCATION_ENTRY_COL_DISPLAY_NAME, &name,
+                            LOC_GIS_LOCATION_ENTRY_COL_LOCATION, &priv->location,
+                            -1);
+        gtk_entry_set_text (GTK_ENTRY (entry), name);
+        priv->custom_text = FALSE;
+        g_free (name);
     } else if (loc) {
-	priv->location = gweather_location_ref (loc);
-	gtk_entry_set_text (GTK_ENTRY (entry), gweather_location_get_name (loc));
-	priv->custom_text = FALSE;
+        priv->location = g_object_ref (loc);
+        gtk_entry_set_text (GTK_ENTRY (entry), gweather_location_get_name (loc));
+        priv->custom_text = FALSE;
     } else {
-	priv->location = NULL;
-	gtk_entry_set_text (GTK_ENTRY (entry), "");
-	priv->custom_text = TRUE;
+        priv->location = NULL;
+        gtk_entry_set_text (GTK_ENTRY (entry), "");
+        priv->custom_text = TRUE;
     }
 
     gtk_editable_set_position (GTK_EDITABLE (entry), -1);
@@ -338,8 +334,8 @@ set_location_internal (GWeatherLocationEntry *entry,
 }
 
 /**
- * gweather_location_entry_set_location:
- * @entry: a #GWeatherLocationEntry
+ * gis_location_entry_set_location:
+ * @entry: a #GisLocationEntry
  * @loc: (allow-none): a #GWeatherLocation in @entry, or %NULL to
  * clear @entry
  *
@@ -349,85 +345,84 @@ set_location_internal (GWeatherLocationEntry *entry,
  * equal to @loc, that will be chosen in place of @loc.
  **/
 void
-gweather_location_entry_set_location (GWeatherLocationEntry *entry,
-				      GWeatherLocation      *loc)
+gis_location_entry_set_location (GisLocationEntry *entry,
+                                 GWeatherLocation *loc)
 {
     GtkEntryCompletion *completion;
     GtkTreeModel *model;
     GtkTreeIter iter;
-    GWeatherLocation *cmploc;
+    g_autoptr(GWeatherLocation) cmploc = NULL;
 
-    g_return_if_fail (GWEATHER_IS_LOCATION_ENTRY (entry));
+    g_return_if_fail (GIS_IS_LOCATION_ENTRY (entry));
 
     completion = gtk_entry_get_completion (GTK_ENTRY (entry));
     model = gtk_entry_completion_get_model (completion);
 
     if (loc == NULL) {
-	set_location_internal (entry, model, NULL, NULL);
-	return;
+        set_location_internal (entry, model, NULL, NULL);
+        return;
     }
 
     gtk_tree_model_get_iter_first (model, &iter);
     do {
-	gtk_tree_model_get (model, &iter,
-			    LOC_GWEATHER_LOCATION_ENTRY_COL_LOCATION, &cmploc,
-			    -1);
-	if (gweather_location_equal (loc, cmploc)) {
-	    set_location_internal (entry, model, &iter, NULL);
-	    gweather_location_unref (cmploc);
-	    return;
-	}
-
-	gweather_location_unref (cmploc);
+        gtk_tree_model_get (model, &iter,
+                            LOC_GIS_LOCATION_ENTRY_COL_LOCATION, &cmploc,
+                            -1);
+        if (gweather_location_equal (loc, cmploc)) {
+            set_location_internal (entry, model, &iter, NULL);
+            return;
+        }
+
+        g_clear_object (&cmploc);
     } while (gtk_tree_model_iter_next (model, &iter));
 
     set_location_internal (entry, model, NULL, loc);
 }
 
 /**
- * gweather_location_entry_get_location:
- * @entry: a #GWeatherLocationEntry
+ * gis_location_entry_get_location:
+ * @entry: a #GisLocationEntry
  *
  * Gets the location that was set by a previous call to
- * gweather_location_entry_set_location() or was selected by the user.
+ * gis_location_entry_set_location() or was selected by the user.
  *
  * Return value: (transfer full) (allow-none): the selected location
  * (which you must unref when you are done with it), or %NULL if no
  * location is selected.
  **/
 GWeatherLocation *
-gweather_location_entry_get_location (GWeatherLocationEntry *entry)
+gis_location_entry_get_location (GisLocationEntry *entry)
 {
-    g_return_val_if_fail (GWEATHER_IS_LOCATION_ENTRY (entry), NULL);
+    g_return_val_if_fail (GIS_IS_LOCATION_ENTRY (entry), NULL);
 
     if (entry->priv->location)
-	return gweather_location_ref (entry->priv->location);
+        return g_object_ref (entry->priv->location);
     else
-	return NULL;
+        return NULL;
 }
 
 /**
- * gweather_location_entry_has_custom_text:
- * @entry: a #GWeatherLocationEntry
+ * gis_location_entry_has_custom_text:
+ * @entry: a #GisLocationEntry
  *
  * Checks whether or not @entry's text has been modified by the user.
  * Note that this does not mean that no location is associated with @entry.
- * gweather_location_entry_get_location() should be used for this.
+ * gis_location_entry_get_location() should be used for this.
  *
  * Return value: %TRUE if @entry's text was modified by the user, or %FALSE if
  * it's set to the default text of a location.
  **/
 gboolean
-gweather_location_entry_has_custom_text (GWeatherLocationEntry *entry)
+gis_location_entry_has_custom_text (GisLocationEntry *entry)
 {
-    g_return_val_if_fail (GWEATHER_IS_LOCATION_ENTRY (entry), FALSE);
+    g_return_val_if_fail (GIS_IS_LOCATION_ENTRY (entry), FALSE);
 
     return entry->priv->custom_text;
 }
 
 /**
- * gweather_location_entry_set_city:
- * @entry: a #GWeatherLocationEntry
+ * gis_location_entry_set_city:
+ * @entry: a #GisLocationEntry
  * @city_name: (allow-none): the city name, or %NULL
  * @code: the METAR station code
  *
@@ -439,18 +434,16 @@ gweather_location_entry_has_custom_text (GWeatherLocationEntry *entry)
  * %FALSE otherwise.
  **/
 gboolean
-gweather_location_entry_set_city (GWeatherLocationEntry *entry,
-				  const char            *city_name,
-				  const char            *code)
+gis_location_entry_set_city (GisLocationEntry *entry,
+                             const char       *city_name,
+                             const char       *code)
 {
     GtkEntryCompletion *completion;
     GtkTreeModel *model;
     GtkTreeIter iter;
-    GWeatherLocation *cmploc;
     const char *cmpcode;
-    char *cmpname;
 
-    g_return_val_if_fail (GWEATHER_IS_LOCATION_ENTRY (entry), FALSE);
+    g_return_val_if_fail (GIS_IS_LOCATION_ENTRY (entry), FALSE);
     g_return_val_if_fail (code != NULL, FALSE);
 
     completion = gtk_entry_get_completion (GTK_ENTRY (entry));
@@ -458,29 +451,25 @@ gweather_location_entry_set_city (GWeatherLocationEntry *entry,
 
     gtk_tree_model_get_iter_first (model, &iter);
     do {
-	gtk_tree_model_get (model, &iter,
-			    LOC_GWEATHER_LOCATION_ENTRY_COL_LOCATION, &cmploc,
-			    -1);
-
-	cmpcode = gweather_location_get_code (cmploc);
-	if (!cmpcode || strcmp (cmpcode, code) != 0) {
-	    gweather_location_unref (cmploc);
-	    continue;
-	}
-
-	if (city_name) {
-	    cmpname = gweather_location_get_city_name (cmploc);
-	    if (!cmpname || strcmp (cmpname, city_name) != 0) {
-		gweather_location_unref (cmploc);
-		g_free (cmpname);
-		continue;
-	    }
-	    g_free (cmpname);
-	}
-
-	set_location_internal (entry, model, &iter, NULL);
-	gweather_location_unref (cmploc);
-	return TRUE;
+      g_autoptr(GWeatherLocation) cmploc = NULL;
+        gtk_tree_model_get (model, &iter,
+                            LOC_GIS_LOCATION_ENTRY_COL_LOCATION, &cmploc,
+                            -1);
+
+        cmpcode = gweather_location_get_code (cmploc);
+        if (!cmpcode || strcmp (cmpcode, code) != 0) {
+            continue;
+        }
+
+        if (city_name) {
+            g_autofree gchar *cmpname = gweather_location_get_city_name (cmploc);
+            if (!cmpname || strcmp (cmpname, city_name) != 0) {
+                continue;
+            }
+        }
+
+        set_location_internal (entry, model, &iter, NULL);
+        return TRUE;
     } while (gtk_tree_model_iter_next (model, &iter));
 
     set_location_internal (entry, model, NULL, NULL);
@@ -490,11 +479,11 @@ gweather_location_entry_set_city (GWeatherLocationEntry *entry,
 
 static void
 fill_location_entry_model (GtkListStore *store, GWeatherLocation *loc,
-			   const char *parent_display_name,
-			   const char *parent_sort_local_name,
-			   const char *parent_compare_local_name,
-			   const char *parent_compare_english_name,
-			   gboolean show_named_timezones)
+                           const char *parent_display_name,
+                           const char *parent_sort_local_name,
+                           const char *parent_compare_local_name,
+                           const char *parent_compare_english_name,
+                           gboolean show_named_timezones)
 {
     g_autoptr(GWeatherLocation) child = NULL;
     char *display_name, *local_sort_name, *local_compare_name, *english_compare_name;
@@ -502,105 +491,105 @@ fill_location_entry_model (GtkListStore *store, GWeatherLocation *loc,
     switch (gweather_location_get_level (loc)) {
     case GWEATHER_LOCATION_WORLD:
     case GWEATHER_LOCATION_REGION:
-	/* Ignore these levels of hierarchy; just recurse, passing on
-	 * the names from the parent node.
-	 */
-	while ((child = gweather_location_next_child (loc, child)))
-	    fill_location_entry_model (store, child,
-				       parent_display_name,
-				       parent_sort_local_name,
-				       parent_compare_local_name,
-				       parent_compare_english_name,
-				       show_named_timezones);
-	break;
+        /* Ignore these levels of hierarchy; just recurse, passing on
+         * the names from the parent node.
+         */
+        while ((child = gweather_location_next_child (loc, child)))
+            fill_location_entry_model (store, child,
+                                       parent_display_name,
+                                       parent_sort_local_name,
+                                       parent_compare_local_name,
+                                       parent_compare_english_name,
+                                       show_named_timezones);
+        break;
 
     case GWEATHER_LOCATION_COUNTRY:
-	/* Recurse, initializing the names to the country name */
-	while ((child = gweather_location_next_child (loc, child)))
-	    fill_location_entry_model (store, child,
-				       gweather_location_get_name (loc),
-				       gweather_location_get_sort_name (loc),
-				       gweather_location_get_sort_name (loc),
-				       gweather_location_get_english_sort_name (loc),
-				       show_named_timezones);
-	break;
+        /* Recurse, initializing the names to the country name */
+        while ((child = gweather_location_next_child (loc, child)))
+            fill_location_entry_model (store, child,
+                                       gweather_location_get_name (loc),
+                                       gweather_location_get_sort_name (loc),
+                                       gweather_location_get_sort_name (loc),
+                                       gweather_location_get_english_sort_name (loc),
+                                       show_named_timezones);
+        break;
 
     case GWEATHER_LOCATION_ADM1:
-	/* Recurse, adding the ADM1 name to the country name */
-	/* Translators: this is the name of a location followed by a region, for example:
-	 * 'London, United Kingdom'
-	 * You shouldn't need to translate this string unless the language has a different comma.
-	 */
-	display_name = g_strdup_printf (_("%s, %s"), gweather_location_get_name (loc), parent_display_name);
-	local_sort_name = g_strdup_printf ("%s, %s", parent_sort_local_name, gweather_location_get_sort_name (loc));
-	local_compare_name = g_strdup_printf ("%s, %s", gweather_location_get_sort_name (loc), parent_compare_local_name);
-	english_compare_name = g_strdup_printf ("%s, %s", gweather_location_get_english_sort_name (loc), parent_compare_english_name);
-
-	while ((child = gweather_location_next_child (loc, child)))
-	    fill_location_entry_model (store, child,
-				       display_name, local_sort_name, local_compare_name, english_compare_name,
-				       show_named_timezones);
-
-	g_free (display_name);
-	g_free (local_compare_name);
-	g_free (english_compare_name);
-	break;
+        /* Recurse, adding the ADM1 name to the country name */
+        /* Translators: this is the name of a location followed by a region, for example:
+         * 'London, United Kingdom'
+         * You shouldn't need to translate this string unless the language has a different comma.
+         */
+        display_name = g_strdup_printf (_("%s, %s"), gweather_location_get_name (loc), parent_display_name);
+        local_sort_name = g_strdup_printf ("%s, %s", parent_sort_local_name, gweather_location_get_sort_name (loc));
+        local_compare_name = g_strdup_printf ("%s, %s", gweather_location_get_sort_name (loc), parent_compare_local_name);
+        english_compare_name = g_strdup_printf ("%s, %s", gweather_location_get_english_sort_name (loc), parent_compare_english_name);
+
+        while ((child = gweather_location_next_child (loc, child)))
+            fill_location_entry_model (store, child,
+                                       display_name, local_sort_name, local_compare_name, english_compare_name,
+                                       show_named_timezones);
+
+        g_free (display_name);
+        g_free (local_compare_name);
+        g_free (english_compare_name);
+        break;
 
     case GWEATHER_LOCATION_CITY:
-	/* If there are multiple (<location>) children, we use the one
-	 * closest to the city center.
-	 *
-	 * Locations are already sorted by increasing distance from
-	 * the city.
-	 */
+        /* If there are multiple (<location>) children, we use the one
+         * closest to the city center.
+         *
+         * Locations are already sorted by increasing distance from
+         * the city.
+         */
     case GWEATHER_LOCATION_WEATHER_STATION:
-	/* <location> with no parent <city> */
-	/* Translators: this is the name of a location followed by a region, for example:
-	 * 'London, United Kingdom'
-	 * You shouldn't need to translate this string unless the language has a different comma.
-	 */
-	display_name = g_strdup_printf (_("%s, %s"),
-					gweather_location_get_name (loc), parent_display_name);
-	local_sort_name = g_strdup_printf ("%s, %s",
-					   parent_sort_local_name, gweather_location_get_sort_name (loc));
-	local_compare_name = g_strdup_printf ("%s, %s",
-					      gweather_location_get_sort_name (loc), parent_compare_local_name);
-	english_compare_name = g_strdup_printf ("%s, %s",
-						gweather_location_get_english_sort_name (loc), parent_compare_english_name);
-
-	gtk_list_store_insert_with_values (store, NULL, -1,
-					   LOC_GWEATHER_LOCATION_ENTRY_COL_LOCATION, loc,
-					   LOC_GWEATHER_LOCATION_ENTRY_COL_DISPLAY_NAME, display_name,
-					   LOC_GWEATHER_LOCATION_ENTRY_COL_LOCAL_SORT_NAME, local_sort_name,
-					   LOC_GWEATHER_LOCATION_ENTRY_COL_LOCAL_COMPARE_NAME, local_compare_name,
-					   LOC_GWEATHER_LOCATION_ENTRY_COL_ENGLISH_COMPARE_NAME, english_compare_name,
-					   -1);
-
-	g_free (display_name);
-	g_free (local_compare_name);
-	g_free (english_compare_name);
-	break;
+        /* <location> with no parent <city> */
+        /* Translators: this is the name of a location followed by a region, for example:
+         * 'London, United Kingdom'
+         * You shouldn't need to translate this string unless the language has a different comma.
+         */
+        display_name = g_strdup_printf (_("%s, %s"),
+                                        gweather_location_get_name (loc), parent_display_name);
+        local_sort_name = g_strdup_printf ("%s, %s",
+                                           parent_sort_local_name, gweather_location_get_sort_name (loc));
+        local_compare_name = g_strdup_printf ("%s, %s",
+                                              gweather_location_get_sort_name (loc), parent_compare_local_name);
+        english_compare_name = g_strdup_printf ("%s, %s",
+                                                gweather_location_get_english_sort_name (loc), parent_compare_english_name);
+
+        gtk_list_store_insert_with_values (store, NULL, -1,
+                                           LOC_GIS_LOCATION_ENTRY_COL_LOCATION, loc,
+                                           LOC_GIS_LOCATION_ENTRY_COL_DISPLAY_NAME, display_name,
+                                           LOC_GIS_LOCATION_ENTRY_COL_LOCAL_SORT_NAME, local_sort_name,
+                                           LOC_GIS_LOCATION_ENTRY_COL_LOCAL_COMPARE_NAME, local_compare_name,
+                                           LOC_GIS_LOCATION_ENTRY_COL_ENGLISH_COMPARE_NAME, english_compare_name,
+                                           -1);
+
+        g_free (display_name);
+        g_free (local_compare_name);
+        g_free (english_compare_name);
+        break;
 
     case GWEATHER_LOCATION_NAMED_TIMEZONE:
-	if (show_named_timezones) {
-	    gtk_list_store_insert_with_values (store, NULL, -1,
-					       LOC_GWEATHER_LOCATION_ENTRY_COL_LOCATION, loc,
-					       LOC_GWEATHER_LOCATION_ENTRY_COL_DISPLAY_NAME, gweather_location_get_name (loc),
-					       LOC_GWEATHER_LOCATION_ENTRY_COL_LOCAL_SORT_NAME, gweather_location_get_sort_name (loc),
-					       LOC_GWEATHER_LOCATION_ENTRY_COL_LOCAL_COMPARE_NAME, gweather_location_get_sort_name (loc),
-					       LOC_GWEATHER_LOCATION_ENTRY_COL_ENGLISH_COMPARE_NAME, gweather_location_get_english_sort_name (loc),
-					       -1);
-	}
-	break;
+        if (show_named_timezones) {
+            gtk_list_store_insert_with_values (store, NULL, -1,
+                                               LOC_GIS_LOCATION_ENTRY_COL_LOCATION, loc,
+                                               LOC_GIS_LOCATION_ENTRY_COL_DISPLAY_NAME, gweather_location_get_name (loc),
+                                               LOC_GIS_LOCATION_ENTRY_COL_LOCAL_SORT_NAME, gweather_location_get_sort_name (loc),
+                                               LOC_GIS_LOCATION_ENTRY_COL_LOCAL_COMPARE_NAME, gweather_location_get_sort_name (loc),
+                                               LOC_GIS_LOCATION_ENTRY_COL_ENGLISH_COMPARE_NAME, gweather_location_get_english_sort_name (loc),
+                                               -1);
+        }
+        break;
 
     case GWEATHER_LOCATION_DETACHED:
-	g_assert_not_reached ();
+        g_assert_not_reached ();
     }
 }
 
 static char *
 find_word (const char *full_name, const char *word, int word_len,
-	   gboolean whole_word, gboolean is_first_word)
+           gboolean whole_word, gboolean is_first_word)
 {
     char *p;
 
@@ -609,36 +598,36 @@ find_word (const char *full_name, const char *word, int word_len,
 
     p = (char *)full_name - 1;
     while ((p = strchr (p + 1, *word))) {
-	if (strncmp (p, word, word_len) != 0)
-	    continue;
-
-	if (p > (char *)full_name) {
-	    char *prev = g_utf8_prev_char (p);
-
-	    /* Make sure p points to the start of a word */
-	    if (g_unichar_isalpha (g_utf8_get_char (prev)))
-		continue;
-
-	    /* If we're matching the first word of the key, it has to
-	     * match the first word of the location, city, state, or
-	     * country, or the abbreviation (in parenthesis).
-	     * Eg, it either matches the start of the string
-	     * (which we already know it doesn't at this point) or
-	     * it is preceded by the string ", " or "(" (which isn't actually
-	     * a perfect test. FIXME)
-	     */
-	    if (is_first_word) {
-		if (prev == (char *)full_name ||
-		    ((prev - 1 <= full_name && strncmp (prev - 1, ", ", 2) != 0)
-		      && *prev != '('))
-		    continue;
-	    }
-	}
-
-	if (whole_word && g_unichar_isalpha (g_utf8_get_char (p + word_len)))
-	    continue;
-
-	return p;
+        if (strncmp (p, word, word_len) != 0)
+            continue;
+
+        if (p > (char *)full_name) {
+            char *prev = g_utf8_prev_char (p);
+
+            /* Make sure p points to the start of a word */
+            if (g_unichar_isalpha (g_utf8_get_char (prev)))
+                continue;
+
+            /* If we're matching the first word of the key, it has to
+             * match the first word of the location, city, state, or
+             * country, or the abbreviation (in parenthesis).
+             * Eg, it either matches the start of the string
+             * (which we already know it doesn't at this point) or
+             * it is preceded by the string ", " or "(" (which isn't actually
+             * a perfect test. FIXME)
+             */
+            if (is_first_word) {
+                if (prev == (char *)full_name ||
+                    ((prev - 1 <= full_name && strncmp (prev - 1, ", ", 2) != 0)
+                      && *prev != '('))
+                    continue;
+            }
+        }
+
+        if (whole_word && g_unichar_isalpha (g_utf8_get_char (p + word_len)))
+            continue;
+
+        return p;
     }
     return NULL;
 }
@@ -657,45 +646,45 @@ match_compare_name (const char *key, const char *name)
      */
     len = strcspn (key, " ");
     while (key[len]) {
-	name = find_word (name, key, len, TRUE, is_first_word);
-	if (!name)
-	    return FALSE;
-
-	key += len;
-	while (*key && !g_unichar_isalpha (g_utf8_get_char (key)))
-	    key = g_utf8_next_char (key);
-	while (*name && !g_unichar_isalpha (g_utf8_get_char (name)))
-	    name = g_utf8_next_char (name);
-
-	len = strcspn (key, " ");
-	is_first_word = FALSE;
+        name = find_word (name, key, len, TRUE, is_first_word);
+        if (!name)
+            return FALSE;
+
+        key += len;
+        while (*key && !g_unichar_isalpha (g_utf8_get_char (key)))
+            key = g_utf8_next_char (key);
+        while (*name && !g_unichar_isalpha (g_utf8_get_char (name)))
+            name = g_utf8_next_char (name);
+
+        len = strcspn (key, " ");
+        is_first_word = FALSE;
     }
 
     /* The last word in KEY must match a prefix of a following word in NAME */
     if (len == 0) {
-	return TRUE;
+        return TRUE;
     } else {
-	// if we get here, key[len] == 0, so...
-	g_assert (len == strlen(key));
-	return find_word (name, key, len, FALSE, is_first_word) != NULL;
+        // if we get here, key[len] == 0, so...
+        g_assert (len == strlen(key));
+        return find_word (name, key, len, FALSE, is_first_word) != NULL;
     }
 }
 
 static gboolean
 matcher (GtkEntryCompletion *completion, const char *key,
-	 GtkTreeIter *iter, gpointer user_data)
+         GtkTreeIter *iter, gpointer user_data)
 {
     char *local_compare_name, *english_compare_name;
     gboolean match;
 
     gtk_tree_model_get (gtk_entry_completion_get_model (completion), iter,
-			LOC_GWEATHER_LOCATION_ENTRY_COL_LOCAL_COMPARE_NAME, &local_compare_name,
-			LOC_GWEATHER_LOCATION_ENTRY_COL_ENGLISH_COMPARE_NAME, &english_compare_name,
-			-1);
+                        LOC_GIS_LOCATION_ENTRY_COL_LOCAL_COMPARE_NAME, &local_compare_name,
+                        LOC_GIS_LOCATION_ENTRY_COL_ENGLISH_COMPARE_NAME, &english_compare_name,
+                        -1);
 
     match = match_compare_name (key, local_compare_name) ||
-	    match_compare_name (key, english_compare_name) ||
-	    g_ascii_strcasecmp (key, english_compare_name) == 0;
+            match_compare_name (key, english_compare_name) ||
+            g_ascii_strcasecmp (key, english_compare_name) == 0;
 
     g_free (local_compare_name);
     g_free (english_compare_name);
@@ -704,46 +693,46 @@ matcher (GtkEntryCompletion *completion, const char *key,
 
 static gboolean
 match_selected (GtkEntryCompletion *completion,
-		GtkTreeModel       *model,
-		GtkTreeIter        *iter,
-		gpointer            entry)
+                GtkTreeModel       *model,
+                GtkTreeIter        *iter,
+                gpointer            entry)
 {
-    GWeatherLocationEntryPrivate *priv;
+    GisLocationEntryPrivate *priv;
 
-    priv = ((GWeatherLocationEntry *)entry)->priv;
+    priv = ((GisLocationEntry *)entry)->priv;
 
     if (model != priv->model) {
-	GeocodePlace *place;
-	char *display_name;
-	GeocodeLocation *loc;
-	GWeatherLocation *location;
-	GWeatherLocation *scope = NULL;
-	const char* country_code;
-
-	gtk_tree_model_get (model, iter,
-			    PLACE_GWEATHER_LOCATION_ENTRY_COL_PLACE, &place,
-			    PLACE_GWEATHER_LOCATION_ENTRY_COL_DISPLAY_NAME, &display_name,
-			    -1);
-
-	country_code = geocode_place_get_country_code (place);
-	if (country_code != NULL && gweather_location_get_level (priv->top) == GWEATHER_LOCATION_WORLD)
-	    scope = gweather_location_find_by_country_code (priv->top, country_code);
-	if (!scope)
-	    scope = priv->top;
-
-	loc = geocode_place_get_location (place);
-	location = gweather_location_find_nearest_city (scope, geocode_location_get_latitude (loc), geocode_location_get_longitude (loc));
-
-	location = _gweather_location_new_detached (location, display_name, TRUE,
-						     geocode_location_get_latitude (loc) * M_PI / 180.0,
-						     geocode_location_get_longitude (loc) * M_PI / 180.0);
-
-	set_location_internal (entry, model, NULL, location);
-
-	g_object_unref (place);
-	g_free (display_name);
+        GeocodePlace *place;
+        char *display_name;
+        GeocodeLocation *loc;
+        GWeatherLocation *location;
+        GWeatherLocation *scope = NULL;
+        const char* country_code;
+
+        gtk_tree_model_get (model, iter,
+                            PLACE_GIS_LOCATION_ENTRY_COL_PLACE, &place,
+                            PLACE_GIS_LOCATION_ENTRY_COL_DISPLAY_NAME, &display_name,
+                            -1);
+
+        country_code = geocode_place_get_country_code (place);
+        if (country_code != NULL && gweather_location_get_level (priv->top) == GWEATHER_LOCATION_WORLD)
+            scope = gweather_location_find_by_country_code (priv->top, country_code);
+        if (!scope)
+            scope = priv->top;
+
+        loc = geocode_place_get_location (place);
+        location = gweather_location_new_detached (display_name,
+                                                   NULL,
+                                                   geocode_location_get_latitude (loc),
+                                                   geocode_location_get_longitude (loc));
+
+        set_location_internal (entry, model, NULL, location);
+
+        g_object_unref (place);
+        g_object_unref (location);
+        g_free (display_name);
     } else {
-	set_location_internal (entry, model, iter, NULL);
+        set_location_internal (entry, model, iter, NULL);
     }
     return TRUE;
 }
@@ -769,11 +758,11 @@ fill_store (gpointer data, gpointer user_data)
     compare_name = g_utf8_casefold (normalized, -1);
 
     gtk_list_store_insert_with_values (user_data, NULL, -1,
-				       PLACE_GWEATHER_LOCATION_ENTRY_COL_PLACE, place,
-				       PLACE_GWEATHER_LOCATION_ENTRY_COL_DISPLAY_NAME, display_name,
-				       PLACE_GWEATHER_LOCATION_ENTRY_COL_LOCAL_SORT_NAME, compare_name,
-				       PLACE_GWEATHER_LOCATION_ENTRY_COL_LOCAL_COMPARE_NAME, compare_name,
-				       -1);
+                                       PLACE_GIS_LOCATION_ENTRY_COL_PLACE, place,
+                                       PLACE_GIS_LOCATION_ENTRY_COL_DISPLAY_NAME, display_name,
+                                       PLACE_GIS_LOCATION_ENTRY_COL_LOCAL_SORT_NAME, compare_name,
+                                       PLACE_GIS_LOCATION_ENTRY_COL_LOCAL_COMPARE_NAME, compare_name,
+                                       -1);
 
     g_free (normalized);
     g_free (compare_name);
@@ -785,7 +774,7 @@ _got_places (GObject      *source_object,
              gpointer      user_data)
 {
     GList *places;
-    GWeatherLocationEntry *self = user_data;
+    GisLocationEntry *self = user_data;
     GError *error = NULL;
     GtkListStore *store = NULL;
     GtkEntryCompletion *completion;
@@ -821,7 +810,7 @@ _got_places (GObject      *source_object,
 }
 
 static void
-_no_matches (GtkEntryCompletion *completion, GWeatherLocationEntry *entry) {
+_no_matches (GtkEntryCompletion *completion, GisLocationEntry *entry) {
     const gchar *key = gtk_entry_get_text(GTK_ENTRY (entry));
     GeocodeForward *forward;
 
@@ -840,21 +829,21 @@ _no_matches (GtkEntryCompletion *completion, GWeatherLocationEntry *entry) {
 }
 
 /**
- * gweather_location_entry_new:
+ * gis_location_entry_new:
  * @top: the top-level location for the entry.
  *
- * Creates a new #GWeatherLocationEntry.
+ * Creates a new #GisLocationEntry.
  *
  * @top will normally be the location returned from
  * gweather_location_get_world(), but you can create an entry that
  * only accepts a smaller set of locations if you want.
  *
- * Return value: the new #GWeatherLocationEntry
+ * Return value: the new #GisLocationEntry
  **/
 GtkWidget *
-gweather_location_entry_new (GWeatherLocation *top)
+gis_location_entry_new (GWeatherLocation *top)
 {
-    return g_object_new (GWEATHER_TYPE_LOCATION_ENTRY,
-			 "top", top,
-			 NULL);
+    return g_object_new (GIS_TYPE_LOCATION_ENTRY,
+                         "top", top,
+                         NULL);
 }
diff --git a/gnome-initial-setup/pages/timezone/gis-location-entry.h b/gnome-initial-setup/pages/timezone/gis-location-entry.h
index ccd606c7..30c19dbb 100644
--- a/gnome-initial-setup/pages/timezone/gis-location-entry.h
+++ b/gnome-initial-setup/pages/timezone/gis-location-entry.h
@@ -6,52 +6,42 @@
 
 #pragma once
 
-#if !(defined(IN_GWEATHER_H) || defined(GWEATHER_COMPILATION))
-#error "gweather-location-entry.h must not be included individually, include gweather.h instead"
-#endif
-
 #include <gtk/gtk.h>
-#include <libgweather/gweather-location.h>
+#include <libgweather/gweather.h>
 
 G_BEGIN_DECLS
 
-typedef struct _GWeatherLocationEntry GWeatherLocationEntry;
-typedef struct _GWeatherLocationEntryClass GWeatherLocationEntryClass;
-typedef struct _GWeatherLocationEntryPrivate GWeatherLocationEntryPrivate;
+typedef struct _GisLocationEntry GisLocationEntry;
+typedef struct _GisLocationEntryClass GisLocationEntryClass;
+typedef struct _GisLocationEntryPrivate GisLocationEntryPrivate;
 
-#define GWEATHER_TYPE_LOCATION_ENTRY            (gweather_location_entry_get_type ())
-#define GWEATHER_LOCATION_ENTRY(object)         (G_TYPE_CHECK_INSTANCE_CAST ((object), GWEATHER_TYPE_LOCATION_ENTRY, GWeatherLocationEntry))
-#define GWEATHER_LOCATION_ENTRY_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GWEATHER_TYPE_LOCATION_ENTRY, GWeatherLocationEntryClass))
-#define GWEATHER_IS_LOCATION_ENTRY(object)      (G_TYPE_CHECK_INSTANCE_TYPE ((object), GWEATHER_TYPE_LOCATION_ENTRY))
-#define GWEATHER_IS_LOCATION_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GWEATHER_TYPE_LOCATION_ENTRY))
-#define GWEATHER_LOCATION_ENTRY_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GWEATHER_TYPE_LOCATION_ENTRY, GWeatherLocationEntryClass))
+#define GIS_TYPE_LOCATION_ENTRY (gis_location_entry_get_type ())
+#define GIS_LOCATION_ENTRY(object)         (G_TYPE_CHECK_INSTANCE_CAST ((object), GIS_TYPE_LOCATION_ENTRY, GisLocationEntry))
+#define GIS_LOCATION_ENTRY_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GIS_TYPE_LOCATION_ENTRY, GisLocationEntryClass))
+#define GIS_IS_LOCATION_ENTRY(object)      (G_TYPE_CHECK_INSTANCE_TYPE ((object), GIS_TYPE_LOCATION_ENTRY))
+#define GIS_IS_LOCATION_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GIS_TYPE_LOCATION_ENTRY))
+#define GIS_LOCATION_ENTRY_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GIS_TYPE_LOCATION_ENTRY, GisLocationEntryClass))
 
-struct _GWeatherLocationEntry {
+struct _GisLocationEntry {
     GtkSearchEntry parent;
 
     /*< private >*/
-    GWeatherLocationEntryPrivate *priv;
+    GisLocationEntryPrivate *priv;
 };
 
-struct _GWeatherLocationEntryClass {
+struct _GisLocationEntryClass {
     GtkSearchEntryClass parent_class;
 };
 
-GWEATHER_AVAILABLE_IN_ALL
-GType                   gweather_location_entry_get_type        (void);
-
-GWEATHER_AVAILABLE_IN_ALL
-GtkWidget *             gweather_location_entry_new             (GWeatherLocation *top);
-GWEATHER_AVAILABLE_IN_ALL
-void                    gweather_location_entry_set_location    (GWeatherLocationEntry *entry,
-                                                                 GWeatherLocation *loc);
-GWEATHER_AVAILABLE_IN_ALL
-GWeatherLocation *      gweather_location_entry_get_location    (GWeatherLocationEntry *entry);
-GWEATHER_AVAILABLE_IN_ALL
-gboolean                gweather_location_entry_has_custom_text (GWeatherLocationEntry *entry);
-GWEATHER_AVAILABLE_IN_ALL
-gboolean                gweather_location_entry_set_city        (GWeatherLocationEntry *entry,
-                                                                 const char *city_name,
-                                                                 const char *code);
+GType                   gis_location_entry_get_type        (void);
+
+GtkWidget *             gis_location_entry_new             (GWeatherLocation *top);
+void                    gis_location_entry_set_location    (GisLocationEntry *entry,
+                                                            GWeatherLocation *loc);
+GWeatherLocation *      gis_location_entry_get_location    (GisLocationEntry *entry);
+gboolean                gis_location_entry_has_custom_text (GisLocationEntry *entry);
+gboolean                gis_location_entry_set_city        (GisLocationEntry *entry,
+                                                            const char       *city_name,
+                                                            const char       *code);
 
 G_END_DECLS
diff --git a/gnome-initial-setup/pages/timezone/meson.build b/gnome-initial-setup/pages/timezone/meson.build
index 1c4853d2..04c2f922 100644
--- a/gnome-initial-setup/pages/timezone/meson.build
+++ b/gnome-initial-setup/pages/timezone/meson.build
@@ -23,6 +23,8 @@ sources += files(
     'tz.h',
     'gis-bubble-widget.c',
     'gis-bubble-widget.h',
+    'gis-location-entry.c',
+    'gis-location-entry.h',
     'gis-timezone-page.c',
     'gis-timezone-page.h'
 )
-- 
GitLab


From a7dfea203494c285cd222f44cf05e9e07bfd6b38 Mon Sep 17 00:00:00 2001
From: Will Thompson <will@willthompson.co.uk>
Date: Tue, 4 Jan 2022 13:28:03 +0000
Subject: [PATCH 4/4] timezone: Reintroduce GisLocationEntry

https://gitlab.gnome.org/GNOME/gnome-initial-setup/-/issues/132

Part-of: <https://gitlab.gnome.org/GNOME/gnome-initial-setup/-/merge_requests/133>
---
 gnome-initial-setup/pages/timezone/gis-timezone-page.c  | 9 +++------
 gnome-initial-setup/pages/timezone/gis-timezone-page.ui | 2 +-
 2 files changed, 4 insertions(+), 7 deletions(-)

diff --git a/gnome-initial-setup/pages/timezone/gis-timezone-page.c b/gnome-initial-setup/pages/timezone/gis-timezone-page.c
index e0a6d3df..c4a5b5de 100644
--- a/gnome-initial-setup/pages/timezone/gis-timezone-page.c
+++ b/gnome-initial-setup/pages/timezone/gis-timezone-page.c
@@ -49,6 +49,7 @@
 #include "gis-bubble-widget.h"
 
 #include "gis-page-header.h"
+#include "gis-location-entry.h"
 
 #define DEFAULT_TZ "Europe/London"
 #define DESKTOP_ID "gnome-datetime-panel"
@@ -228,15 +229,14 @@ entry_text_changed (GtkEditable *editable,
   priv->search_entry_text_changed_id = 0;
 }
 
-#if 0
 static void
 entry_location_changed (GObject *object, GParamSpec *param, GisTimezonePage *page)
 {
   GisTimezonePagePrivate *priv = gis_timezone_page_get_instance_private (page);
-  GWeatherLocationEntry *entry = GWEATHER_LOCATION_ENTRY (object);
+  GisLocationEntry *entry = GIS_LOCATION_ENTRY (object);
   g_autoptr(GWeatherLocation) location = NULL;
 
-  location = gweather_location_entry_get_location (entry);
+  location = gis_location_entry_get_location (entry);
   if (!location)
     return;
 
@@ -244,7 +244,6 @@ entry_location_changed (GObject *object, GParamSpec *param, GisTimezonePage *pag
   set_location (page, location);
   priv->in_search = FALSE;
 }
-#endif
 
 #define GETTEXT_PACKAGE_TIMEZONES "gnome-control-center-2.0-timezones"
 
@@ -446,10 +445,8 @@ gis_timezone_page_constructed (GObject *object)
   priv->search_entry_text_changed_id =
       g_signal_connect (priv->search_entry, "changed",
                         G_CALLBACK (entry_text_changed), page);
-#if 0
   g_signal_connect (priv->search_entry, "notify::location",
                     G_CALLBACK (entry_location_changed), page);
-#endif
   g_signal_connect (priv->search_entry, "map",
                     G_CALLBACK (entry_mapped), page);
   g_signal_connect (priv->map, "location-changed",
diff --git a/gnome-initial-setup/pages/timezone/gis-timezone-page.ui b/gnome-initial-setup/pages/timezone/gis-timezone-page.ui
index 1f81d3ed..588ec412 100644
--- a/gnome-initial-setup/pages/timezone/gis-timezone-page.ui
+++ b/gnome-initial-setup/pages/timezone/gis-timezone-page.ui
@@ -28,7 +28,7 @@
             <property name="orientation">vertical</property>
             <property name="spacing">14</property>
             <child>
-              <object class="GtkEntry" id="search_entry">
+              <object class="GisLocationEntry" id="search_entry">
                 <property name="visible">True</property>
                 <property name="halign">center</property>
                 <property name="max-width-chars">55</property>
-- 
GitLab

